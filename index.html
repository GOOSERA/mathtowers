<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Tower Defense</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Main Menu */
        .menu-container {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .menu-container.hidden {
            display: none;
        }

        .game-title {
            font-size: 36px;
            color: #667eea;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .game-subtitle {
            font-size: 16px;
            color: #666;
            margin-bottom: 30px;
        }

        .menu-section {
            margin: 30px 0;
        }

        .menu-section h3 {
            font-size: 20px;
            color: #333;
            margin-bottom: 15px;
        }

        .difficulty-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .difficulty-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
        }

        .difficulty-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .difficulty-btn.selected {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            box-shadow: 0 5px 15px rgba(67, 233, 123, 0.4);
        }

        .start-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 20px 50px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
            font-weight: bold;
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(245, 87, 108, 0.4);
        }

        .instructions {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: left;
            margin: 20px 0;
        }

        .instructions h3 {
            text-align: center;
            margin-bottom: 15px;
        }

        .instructions ul {
            list-style-position: inside;
            color: #555;
            line-height: 1.8;
        }

        .instructions li {
            margin: 8px 0;
        }

        .difficulty-info {
            background: #fff3cd;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }

        .difficulty-info p {
            color: #856404;
            margin: 5px 0;
            font-size: 14px;
        }

        #game-container {
            display: none;
            border-radius: 10px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            background: #000;
            max-width: 100%;
            margin: 0 auto;
        }

        #game-container.active {
            display: block;
        }

        @media (max-width: 850px) {
            #game-container {
                border-radius: 0;
                margin: 0;
            }
            
            .game-hud {
                font-size: 14px;
                padding: 8px 15px;
                gap: 15px;
            }
            
            .hud-value {
                font-size: 16px;
            }
        }

        .math-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            text-align: center;
            min-width: 350px;
        }

        .math-modal.active {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .math-question {
            font-size: 24px;
            color: #333;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .math-timer {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 18px;
            color: #667eea;
            font-weight: bold;
        }

        .math-input {
            width: 100%;
            padding: 12px;
            font-size: 20px;
            border: 2px solid #667eea;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
        }

        .math-submit {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .math-submit:hover {
            transform: scale(1.05);
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        .overlay.active {
            display: block;
        }

        .game-hud {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            color: white;
            display: none;
            gap: 20px;
            z-index: 100;
        }

        .game-hud.active {
            display: flex;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .hud-value {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
        }

        .hud-gold { color: #ffd700; }
        .hud-health { color: #ff6b6b; }
        .hud-wave { color: #4ecdc4; }
        .hud-score { color: #a8e6cf; }
        .hud-noise { color: #ffaa00; }

        .game-over-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            text-align: center;
            min-width: 400px;
        }

        .game-over-modal.active {
            display: block;
            animation: slideIn 0.3s ease;
        }

        .game-over-title {
            font-size: 48px;
            color: #ff6b6b;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .game-over-stats {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .game-over-stat {
            font-size: 20px;
            color: #333;
            margin: 10px 0;
        }

        .game-over-stat strong {
            color: #667eea;
        }

        .restart-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .placement-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            gap: 15px;
            z-index: 200;
        }

        .placement-controls.active {
            display: flex;
        }

        .placement-controls button {
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .placement-controls .confirm-btn {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
        }

        .placement-controls .cancel-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
        }

        .placement-controls button:active {
            transform: scale(0.95);
        }

        .sell-tower-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            text-align: center;
            min-width: 300px;
        }

        .sell-tower-modal.active {
            display: block;
            animation: slideIn 0.3s ease;
        }

        .sell-tower-title {
            font-size: 24px;
            color: #333;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .sell-tower-info {
            font-size: 18px;
            color: #666;
            margin-bottom: 20px;
        }

        .sell-tower-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .sell-tower-buttons button {
            padding: 12px 25px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }

        .sell-confirm-btn {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
        }

        .sell-cancel-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                text-shadow: 0 0 0 rgba(255, 0, 0, 0);
            }
            50% {
                transform: scale(1.1);
                text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            }
            100% {
                transform: scale(1);
                text-shadow: 0 0 0 rgba(255, 0, 0, 0);
            }
        }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div class="menu-container" id="mainMenu">
        <h1 class="game-title">üéØ Math Tower Defense</h1>
        <p class="game-subtitle">Defend your base by solving math problems!</p>

        <div class="menu-section">
            <h3>Select Difficulty</h3>
            <div class="difficulty-buttons">
                <button class="difficulty-btn" data-difficulty="easy" onclick="selectDifficulty('easy')">
                    Easy
                </button>
                <button class="difficulty-btn selected" data-difficulty="normal" onclick="selectDifficulty('normal')">
                    Normal
                </button>
                <button class="difficulty-btn" data-difficulty="hard" onclick="selectDifficulty('hard')">
                    Hard
                </button>
            </div>
            
            <div class="difficulty-info" id="difficultyInfo">
                <p><strong>Normal:</strong> Addition, Subtraction & Multiplication | 30 seconds per problem</p>
            </div>
        </div>

        <div class="instructions">
            <h3>How to Play</h3>
            <ul>
                <li><strong>Earn Gold:</strong> Solve math + Kill enemies + Complete waves</li>
                <li><strong>Place Towers:</strong> Click tower button ‚Üí Position ‚Üí Confirm ‚Üí Solve math</li>
                <li><strong>Noise Meter:</strong> ‚ö†Ô∏è Auto-fire towers add noise. At 50%+ shots start missing!</li>
                <li><strong>Math Towers:</strong> Glow yellow when ready - click to solve math and fire!</li>
                <li><strong>Sell Towers:</strong> Click any tower to sell for 50% refund</li>
            </ul>
        </div>

        <button class="start-btn" onclick="startGame()">
            Start Game
        </button>
    </div>
    
    <div id="game-container"></div>
    
    <!-- Math Problem Modal -->
    <div class="overlay" id="overlay"></div>
    <div class="math-modal" id="mathModal">
        <div class="math-timer" id="mathTimer">10s</div>
        <div class="math-question" id="mathQuestion">5 + 3 = ?</div>
        <input type="number" class="math-input" id="mathInput" autofocus>
        <button class="math-submit" onclick="submitAnswer()">Submit Answer</button>
    </div>

    <!-- Game HUD -->
    <div class="game-hud" id="gameHud">
        <div class="hud-item">
            <span>Gold:</span>
            <span class="hud-value hud-gold" id="hudGold">0</span>
        </div>
        <div class="hud-item">
            <span>Health:</span>
            <span class="hud-value hud-health" id="hudHealth">100</span>
        </div>
        <div class="hud-item">
            <span>Wave:</span>
            <span class="hud-value hud-wave" id="hudWave">0</span>
        </div>
        <div class="hud-item">
            <span>Score:</span>
            <span class="hud-value hud-score" id="hudScore">0</span>
        </div>
        <div class="hud-item">
            <span>Noise:</span>
            <span class="hud-value hud-noise" id="hudNoise">0%</span>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="game-over-modal" id="gameOverModal">
        <h1 class="game-over-title">Game Over!</h1>
        <div class="game-over-stats">
            <div class="game-over-stat">
                <strong>Final Score:</strong> <span id="finalScore">0</span>
            </div>
            <div class="game-over-stat">
                <strong>Waves Completed:</strong> <span id="finalWave">0</span>
            </div>
            <div class="game-over-stat">
                <strong>Enemies Defeated:</strong> <span id="finalEnemies">0</span>
            </div>
        </div>
        <button class="restart-btn" onclick="restartGame()">Play Again</button>
    </div>

    <!-- Placement Controls -->
    <div class="placement-controls" id="placementControls">
        <button class="confirm-btn" onclick="confirmTowerPlacement()">
            ‚úÖ Confirm
        </button>
        <button class="cancel-btn" onclick="cancelTowerPlacement()">
            ‚ùå Cancel
        </button>
    </div>

    <!-- Sell Tower Modal -->
    <div class="sell-tower-modal" id="sellTowerModal">
        <h2 class="sell-tower-title">Sell Tower?</h2>
        <p class="sell-tower-info" id="sellTowerInfo">Sell for 50g?</p>
        <div class="sell-tower-buttons">
            <button class="sell-confirm-btn" onclick="confirmSellTower()">
                üí∞ Sell
            </button>
            <button class="sell-cancel-btn" onclick="cancelSellTower()">
                ‚ùå Cancel
            </button>
        </div>
    </div>

    <!-- Load Phaser 3 from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    
    <!-- Shared variables -->
    <script>
        let selectedDifficulty = 'normal';
        let gameStarted = false;

        function selectDifficulty(difficulty) {
            selectedDifficulty = difficulty;
            
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.dataset.difficulty === difficulty) {
                    btn.classList.add('selected');
                }
            });
            
            const info = {
                easy: '<p><strong>Easy:</strong> Addition & Subtraction only | 60 seconds per problem</p>',
                normal: '<p><strong>Normal:</strong> Addition, Subtraction & Multiplication | 30 seconds per problem</p>',
                hard: '<p><strong>Hard:</strong> Multiplication, Division & Subtraction | 20 seconds per problem</p>'
            };
            
            document.getElementById('difficultyInfo').innerHTML = info[difficulty];
        }

        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('game-container').classList.add('active');
            document.getElementById('gameHud').classList.add('active');
            
            console.log('Creating game with difficulty:', selectedDifficulty);
            game = new Phaser.Game(config);
        }

        let currentMathCallback = null;
        let mathTimer = null;
        let timeLeft = 10;

        function showMathProblem(question, timeLimit, callback) {
            currentMathCallback = callback;
            timeLeft = timeLimit || 10;
            
            document.getElementById('mathQuestion').textContent = question;
            document.getElementById('mathInput').value = '';
            document.getElementById('mathTimer').textContent = timeLeft + 's';
            
            document.getElementById('overlay').classList.add('active');
            document.getElementById('mathModal').classList.add('active');
            
            document.getElementById('mathInput').focus();
            
            mathTimer = setInterval(() => {
                timeLeft--;
                document.getElementById('mathTimer').textContent = timeLeft + 's';
                
                if (timeLeft <= 0) {
                    closeMathModal(false);
                }
            }, 1000);
        }

        function submitAnswer() {
            const answer = parseFloat(document.getElementById('mathInput').value);
            if (!isNaN(answer)) {
                closeMathModal(true, answer);
            }
        }

        function closeMathModal(answered, answer) {
            clearInterval(mathTimer);
            
            document.getElementById('overlay').classList.remove('active');
            document.getElementById('mathModal').classList.remove('active');
            
            if (currentMathCallback) {
                currentMathCallback(answered, answer);
                currentMathCallback = null;
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('mathInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitAnswer();
                }
            });
        });

        function updateHUD(gold, health, wave, score, noise) {
            document.getElementById('hudGold').textContent = gold;
            document.getElementById('hudHealth').textContent = health;
            document.getElementById('hudWave').textContent = wave;
            document.getElementById('hudScore').textContent = score;
            
            const noiseElement = document.getElementById('hudNoise');
            
            if (noise >= 50) {
                noiseElement.textContent = Math.round(noise) + '% ‚ö†Ô∏è';
                noiseElement.style.color = '#ff0000';
                noiseElement.style.animation = 'pulse 1s infinite';
            } else if (noise >= 35) {
                noiseElement.textContent = Math.round(noise) + '%';
                noiseElement.style.color = '#ff9900';
                noiseElement.style.animation = 'none';
            } else {
                noiseElement.textContent = Math.round(noise) + '%';
                noiseElement.style.color = '#00ff00';
                noiseElement.style.animation = 'none';
            }
        }

        function restartGame() {
            document.getElementById('gameOverModal').classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
            
            if (game) {
                game.destroy(true);
            }
            
            gameStarted = false;
            
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('game-container').classList.remove('active');
            document.getElementById('gameHud').classList.remove('active');
        }
    </script>
    
    <!-- Game Code -->
    <script>
const config = {
    type: Phaser.AUTO,
    scale: {
        mode: Phaser.Scale.FIT,
        parent: 'game-container',
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: 800,
        height: 600
    },
    backgroundColor: '#2d5016',
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

let game = null;

let gameState = {
    gold: 100,
    health: 100,
    wave: 0,
    score: 0,
    difficulty: 'normal',
    towers: [],
    enemies: [],
    projectiles: [],
    selectedTowerType: null,
    isPlacingTower: false,
    waveInProgress: false,
    gameOver: false,
    enemiesDefeated: 0,
    enemiesSpawnedThisWave: 0,
    totalEnemiesToSpawn: 0,
    totalProblemsCompleted: 0,
    noise: 0,
    path: [],
    unlockedTowers: ['basic', 'math-archer'],
    base: null,
    preview: {
        tower: null,
        range: null,
        cost: null
    },
    pendingPlacement: null,
    sellMode: false,
    selectedTowerToSell: null
};

const TOWER_TYPES = {
    'basic': {
        name: 'Basic Tower',
        cost: 100,
        damage: 10,
        range: 120,
        fireRate: 1000,
        color: 0x808080,
        requiresMath: false,
        description: 'Auto-fires at enemies'
    },
    'math-archer': {
        name: 'Math Archer',
        cost: 150,
        damage: 25,
        range: 150,
        fireRate: 1200,
        color: 0x0066ff,
        requiresMath: true,
        description: 'Click when ready to solve math and fire'
    },
    'math-cannon': {
        name: 'Support Aura',
        cost: 200,
        damage: 0,
        range: 180,
        fireRate: 0,
        color: 0xff6600,
        requiresMath: false,
        isSupportTower: true,
        auraRange: 180,
        description: 'Makes nearby math towers auto-fire at bosses!',
        unlockRequirement: { difficulty: 'easy', problems: 10 }
    }
};

const ENEMY_TYPES = {
    'basic': { health: 30, baseSpeed: 50, gold: 10, color: 0x00ff00 },
    'fast': { health: 20, baseSpeed: 80, gold: 15, color: 0xffff00 },
    'tank': { health: 80, baseSpeed: 35, gold: 25, color: 0xff0000 },
    'boss': { health: 200, baseSpeed: 35, gold: 100, color: 0xff00ff, isBoss: true }
};

function preload() {
    console.log('üé® Loading sprites...');
    
    // ‚úÖ LOAD YOUR SPRITES HERE
    // Single idle image
    this.load.image('tower_basic_idle', 'sprites/BasicTowerIdle.png');
    
    // 19-frame spritesheet for firing animation
    this.load.spritesheet('tower_basic_shoot', 'sprites/BasicTowerShoot.png', { 
        frameWidth: 160, 
        frameHeight: 128 
    });
    
    // Other tower sprites (using circle fallbacks for now)
    this.load.image('tower_math_archer', 'sprites/tower_math_archer.png');
    this.load.image('tower_support', 'sprites/tower_support.png');
    
    // Enemy sprites
    this.load.spritesheet('enemy_basic', 'sprites/enemy_basic.png', { frameWidth: 32, frameHeight: 32 });
    this.load.spritesheet('enemy_fast', 'sprites/enemy_fast.png', { frameWidth: 32, frameHeight: 32 });
    this.load.spritesheet('enemy_tank', 'sprites/enemy_tank.png', { frameWidth: 32, frameHeight: 32 });
    this.load.spritesheet('enemy_boss', 'sprites/enemy_boss.png', { frameWidth: 64, frameHeight: 64 });
    
    // Projectile
    this.load.image('projectile', 'sprites/projectile.png');
    
    // Log loading status
    this.load.on('filecomplete', (key, type, data) => {
        console.log('‚úÖ Loaded:', key);
    });
    
    this.load.on('loaderror', (file) => {
        console.warn('‚ö†Ô∏è Failed to load:', file.key, '- Will use fallback graphics');
    });
}

function create() {
    gameState.difficulty = selectedDifficulty;
    console.log('Game started with difficulty:', gameState.difficulty);
    
    // ‚úÖ CREATE ANIMATIONS FOR BASIC TOWER
    createTowerAnimations(this);
    createEnemyAnimations(this);
    
    gameState.path = [
        { x: -20, y: 300 },
        { x: 150, y: 300 },
        { x: 150, y: 150 },
        { x: 350, y: 150 },
        { x: 350, y: 400 },
        { x: 550, y: 400 },
        { x: 550, y: 250 },
        { x: 750, y: 250 },
        { x: 820, y: 250 }
    ];
    
    drawBackground(this);
    drawPath(this);
    drawSpawnAndBase(this);
    createUI(this);
    setupInput(this);
    
    updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
}

function createTowerAnimations(scene) {
    // ‚úÖ IDLE ANIMATION - Uses single image
    if (scene.textures.exists('tower_basic_idle')) {
        console.log('‚úÖ tower_basic_idle texture loaded');
        scene.anims.create({
            key: 'tower_basic_idle',
            frames: [{ key: 'tower_basic_idle' }],
            frameRate: 1,
            repeat: -1
        });
    } else {
        console.warn('‚ùå tower_basic_idle texture NOT found');
    }
    
    // ‚úÖ FIRE ANIMATION - Uses 19-frame spritesheet (frames 0-18)
    if (scene.textures.exists('tower_basic_shoot')) {
        console.log('‚úÖ tower_basic_shoot spritesheet loaded');
        scene.anims.create({
            key: 'tower_basic_shoot',
            frames: scene.anims.generateFrameNumbers('tower_basic_shoot', { 
                start: 0, 
                end: 18  // 19 frames (0-18)
            }),
            frameRate: 20,  // Adjust speed: 15-24 recommended
            repeat: 0       // Play once per shot
        });
        console.log('‚úÖ Created fire animation with 19 frames');
    } else {
        console.warn('‚ùå tower_basic_shoot spritesheet NOT found');
    }
    
    console.log('Tower animations created');
}

function createEnemyAnimations(scene) {
    if (scene.textures.exists('enemy_basic')) {
        scene.anims.create({
            key: 'enemy_basic_walk',
            frames: scene.anims.generateFrameNumbers('enemy_basic', { start: 0, end: 3 }),
            frameRate: 8,
            repeat: -1
        });
    }
    
    if (scene.textures.exists('enemy_fast')) {
        scene.anims.create({
            key: 'enemy_fast_walk',
            frames: scene.anims.generateFrameNumbers('enemy_fast', { start: 0, end: 3 }),
            frameRate: 12,
            repeat: -1
        });
    }
    
    if (scene.textures.exists('enemy_tank')) {
        scene.anims.create({
            key: 'enemy_tank_walk',
            frames: scene.anims.generateFrameNumbers('enemy_tank', { start: 0, end: 3 }),
            frameRate: 6,
            repeat: -1
        });
    }
    
    if (scene.textures.exists('enemy_boss')) {
        scene.anims.create({
            key: 'enemy_boss_walk',
            frames: scene.anims.generateFrameNumbers('enemy_boss', { start: 0, end: 3 }),
            frameRate: 6,
            repeat: -1
        });
    }
}

function drawBackground(scene) {
    const bg = scene.add.graphics();
    bg.fillStyle(0x4a7c59, 1);
    bg.fillRect(0, 0, 800, 600);
    
    for (let i = 0; i < 20; i++) {
        const x = Math.random() * 800;
        const y = Math.random() * 600;
        const size = 20 + Math.random() * 30;
        bg.fillStyle(0x3d6b4a, 0.3);
        bg.fillCircle(x, y, size);
    }
}

function drawPath(scene) {
    const graphics = scene.add.graphics();
    
    graphics.lineStyle(44, 0x000000, 0.2);
    graphics.beginPath();
    for (let i = 0; i < gameState.path.length; i++) {
        const point = gameState.path[i];
        if (i === 0) {
            graphics.moveTo(point.x + 2, point.y + 2);
        } else {
            graphics.lineTo(point.x + 2, point.y + 2);
        }
    }
    graphics.strokePath();
    
    graphics.lineStyle(40, 0x8b7355, 1);
    graphics.beginPath();
    for (let i = 0; i < gameState.path.length; i++) {
        const point = gameState.path[i];
        if (i === 0) {
            graphics.moveTo(point.x, point.y);
        } else {
            graphics.lineTo(point.x, point.y);
        }
    }
    graphics.strokePath();
}

function drawSpawnAndBase(scene) {
    const spawnPoint = gameState.path[0];
    const basePoint = gameState.path[gameState.path.length - 1];
    
    const spawnGraphics = scene.add.graphics();
    spawnGraphics.fillStyle(0xff0000, 0.5);
    spawnGraphics.fillCircle(spawnPoint.x, spawnPoint.y, 35);
    spawnGraphics.lineStyle(3, 0xff0000, 1);
    spawnGraphics.strokeCircle(spawnPoint.x, spawnPoint.y, 35);
    
    scene.add.text(spawnPoint.x, spawnPoint.y - 50, 'SPAWN', {
        fontSize: '14px',
        color: '#ff0000',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 3
    }).setOrigin(0.5);
    
    const baseGraphics = scene.add.graphics();
    baseGraphics.fillStyle(0x8b8b8b, 1);
    baseGraphics.fillRect(basePoint.x - 30, basePoint.y - 40, 60, 80);
    baseGraphics.lineStyle(3, 0x00ff00, 1);
    baseGraphics.strokeRect(basePoint.x - 32, basePoint.y - 42, 64, 84);
    
    scene.add.text(basePoint.x, basePoint.y - 85, 'BASE', {
        fontSize: '16px',
        color: '#00ff00',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 3
    }).setOrigin(0.5);
    
    gameState.base = {
        x: basePoint.x,
        y: basePoint.y,
        healthBarBg: scene.add.rectangle(basePoint.x, basePoint.y + 55, 60, 8, 0x000000),
        healthBar: scene.add.rectangle(basePoint.x, basePoint.y + 55, 60, 8, 0x00ff00)
    };
}

function createUI(scene) {
    const towerButtons = [];
    let yPos = 20;
    
    for (const [key, tower] of Object.entries(TOWER_TYPES)) {
        const isUnlocked = gameState.unlockedTowers.includes(key);
        
        const button = scene.add.rectangle(720, yPos, 140, 50, isUnlocked ? 0x4a4a4a : 0x2a2a2a);
        button.setStrokeStyle(2, isUnlocked ? 0xffffff : 0x666666);
        
        if (isUnlocked) {
            button.setInteractive({ useHandCursor: true });
        }
        
        const text = scene.add.text(720, yPos, 
            isUnlocked ? `${tower.name}\n${tower.cost}g` : 'LOCKED', 
            {
                fontSize: '11px',
                color: isUnlocked ? '#ffffff' : '#666666',
                align: 'center'
            }
        ).setOrigin(0.5);
        
        if (isUnlocked) {
            button.on('pointerdown', () => {
                selectTowerType(scene, key);
            });
        }
        
        towerButtons.push({ button, text, key });
        yPos += 70;
    }
    
    const waveButton = scene.add.rectangle(720, 450, 140, 50, 0x00aa00);
    waveButton.setStrokeStyle(2, 0xffffff);
    waveButton.setInteractive({ useHandCursor: true });
    const waveText = scene.add.text(720, 450, 'Start Wave 1', {
        fontSize: '16px',
        color: '#ffffff'
    }).setOrigin(0.5);
    
    waveButton.on('pointerdown', () => {
        if (!gameState.waveInProgress && !gameState.gameOver) {
            gameState.waveInProgress = true;
            waveButton.disableInteractive();
            waveButton.setFillStyle(0x666666);
            waveText.setText('Wave in Progress...');
            waveText.setColor('#aaaaaa');
            
            startWave(scene);
        }
    });
    
    scene.towerButtons = towerButtons;
    scene.waveButton = waveButton;
    scene.waveText = waveText;
}

function selectTowerType(scene, towerType) {
    if (gameState.gameOver) return;
    
    if (gameState.isPlacingTower) {
        if (gameState.preview.tower) gameState.preview.tower.destroy();
        if (gameState.preview.range) gameState.preview.range.destroy();
        if (gameState.preview.cost) gameState.preview.cost.destroy();
        gameState.preview = { tower: null, range: null, cost: null };
    }
    
    gameState.selectedTowerType = towerType;
    gameState.isPlacingTower = true;
    gameState.pendingPlacement = null;
    
    const towerDef = TOWER_TYPES[towerType];
    
    gameState.preview.tower = scene.add.circle(0, 0, 15, towerDef.color, 0.5);
    gameState.preview.range = scene.add.circle(0, 0, towerDef.range, 0xffffff, 0);
    gameState.preview.range.setStrokeStyle(2, 0xffffff, 0.5);
    gameState.preview.cost = scene.add.text(0, 0, `Cost: ${towerDef.cost}g`, {
        fontSize: '14px',
        color: '#ffff00',
        stroke: '#000000',
        strokeThickness: 3
    }).setOrigin(0.5);
    
    document.getElementById('placementControls').classList.add('active');
}

function setupInput(scene) {
    scene.input.on('pointermove', (pointer) => {
        if (gameState.isPlacingTower) {
            gameState.preview.tower.setPosition(pointer.x, pointer.y);
            gameState.preview.range.setPosition(pointer.x, pointer.y);
            gameState.preview.cost.setPosition(pointer.x, pointer.y - 25);
            
            const towerDef = TOWER_TYPES[gameState.selectedTowerType];
            const canPlace = pointer.x < 650 && !isOnPath(pointer.x, pointer.y);
            const canAfford = gameState.gold >= towerDef.cost;
            
            if (canPlace && canAfford) {
                gameState.preview.tower.setAlpha(0.7);
                gameState.preview.cost.setColor('#00ff00');
            } else {
                gameState.preview.tower.setAlpha(0.3);
                gameState.preview.cost.setColor('#ff0000');
                if (!canAfford) {
                    gameState.preview.cost.setText(`Need ${towerDef.cost}g`);
                } else {
                    gameState.preview.cost.setText(`Cost: ${towerDef.cost}g`);
                }
            }
        }
    });
    
    scene.input.on('pointerdown', (pointer) => {
        if (gameState.gameOver) return;
        if (pointer.x >= 650) return;
        
        if (gameState.isPlacingTower) {
            const towerDef = TOWER_TYPES[gameState.selectedTowerType];
            
            if (pointer.x < 650 && !isOnPath(pointer.x, pointer.y)) {
                gameState.pendingPlacement = {
                    x: pointer.x,
                    y: pointer.y,
                    type: gameState.selectedTowerType,
                    scene: scene
                };
            }
        }
    });
    
    scene.input.keyboard.on('keydown-C', () => {
        cancelTowerPlacement();
    });
    
    scene.input.keyboard.on('keydown-ESC', () => {
        cancelTowerPlacement();
    });
    
    scene.input.keyboard.on('keydown-ENTER', () => {
        const mathModalOpen = document.getElementById('mathModal').classList.contains('active');
        
        if (mathModalOpen) return;
        
        if (gameState.isPlacingTower && gameState.pendingPlacement) {
            confirmTowerPlacement();
        }
    });
}

function cancelTowerPlacement() {
    if (gameState.isPlacingTower) {
        cleanupPlacement();
    }
}

function confirmTowerPlacement() {
    if (!gameState.isPlacingTower) return;
    if (!gameState.pendingPlacement) return;
    
    const towerDef = TOWER_TYPES[gameState.selectedTowerType];
    const scene = gameState.pendingPlacement.scene;
    
    if (!scene) {
        cancelTowerPlacement();
        return;
    }
    
    if (gameState.gold < towerDef.cost) {
        alert(`Not enough gold! Need ${towerDef.cost}g but only have ${gameState.gold}g`);
        return;
    }
    
    const x = gameState.pendingPlacement.x;
    const y = gameState.pendingPlacement.y;
    
    if (x >= 650 || isOnPath(x, y)) {
        alert('Invalid placement!');
        return;
    }
    
    let timeLimit;
    if (gameState.difficulty === 'easy') {
        timeLimit = 60;
    } else if (gameState.difficulty === 'normal') {
        timeLimit = 30;
    } else {
        timeLimit = 20;
    }
    
    const problem = generateMathProblem(gameState.difficulty, towerDef.cost);
    
    showMathProblem(problem.question, timeLimit, (answered, answer) => {
        if (answered && answer === problem.answer) {
            let goldReward = 0;
            if (gameState.difficulty === 'easy') {
                goldReward = 30;
            } else if (gameState.difficulty === 'normal') {
                goldReward = 75;
            } else {
                goldReward = 100;
            }
            
            gameState.gold += goldReward;
            gameState.totalProblemsCompleted++;
            gameState.gold -= towerDef.cost;
            
            checkTowerUnlocks(scene);
            placeTower(scene, gameState.pendingPlacement.x, gameState.pendingPlacement.y, gameState.pendingPlacement.type);
            updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
        }
        
        cleanupPlacement();
    });
}

function cleanupPlacement() {
    gameState.pendingPlacement = null;
    
    if (gameState.preview.tower) {
        gameState.preview.tower.destroy();
        gameState.preview.tower = null;
    }
    if (gameState.preview.range) {
        gameState.preview.range.destroy();
        gameState.preview.range = null;
    }
    if (gameState.preview.cost) {
        gameState.preview.cost.destroy();
        gameState.preview.cost = null;
    }
    
    gameState.isPlacingTower = false;
    gameState.selectedTowerType = null;
    
    document.getElementById('placementControls').classList.remove('active');
}

function checkTowerUnlocks(scene) {
    if (!gameState.unlockedTowers.includes('math-cannon')) {
        const requirement = TOWER_TYPES['math-cannon'].unlockRequirement;
        
        if (gameState.difficulty === requirement.difficulty && 
            gameState.totalProblemsCompleted >= requirement.problems) {
            console.log('üéâ UNLOCKED: Support Aura tower!');
            gameState.unlockedTowers.push('math-cannon');
            
            if (scene && scene.towerButtons) {
                updateTowerButtonUI(scene);
            }
        }
    }
}

function updateTowerButtonUI(scene) {
    for (const buttonData of scene.towerButtons) {
        const key = buttonData.key;
        const isUnlocked = gameState.unlockedTowers.includes(key);
        
        if (isUnlocked) {
            buttonData.button.setFillStyle(0x4a4a4a);
            buttonData.button.setStrokeStyle(2, 0xffffff);
            buttonData.button.setInteractive({ useHandCursor: true });
            buttonData.text.setText(TOWER_TYPES[key].name + '\n' + TOWER_TYPES[key].cost + 'g');
            buttonData.text.setColor('#ffffff');
            
            buttonData.button.removeAllListeners('pointerdown');
            buttonData.button.on('pointerdown', () => {
                selectTowerType(scene, key);
            });
        }
    }
}

function showSellTowerModal(tower) {
    gameState.selectedTowerToSell = tower;
    
    const sellPrice = Math.floor(tower.cost * 0.5);
    
    document.getElementById('sellTowerInfo').textContent = 
        `Sell ${tower.name} for ${sellPrice} gold? (50% refund)`;
    
    document.getElementById('overlay').classList.add('active');
    document.getElementById('sellTowerModal').classList.add('active');
}

function confirmSellTower() {
    if (!gameState.selectedTowerToSell) return;
    
    const tower = gameState.selectedTowerToSell;
    const sellPrice = Math.floor(tower.cost * 0.5);
    
    gameState.gold += sellPrice;
    
    if (tower.graphic) tower.graphic.destroy();
    if (tower.rangeCircle) tower.rangeCircle.destroy();
    if (tower.readyIndicator) tower.readyIndicator.destroy();
    if (tower.auraGraphic) tower.auraGraphic.destroy();
    if (tower.noiseWarning) tower.noiseWarning.destroy();
    
    const index = gameState.towers.indexOf(tower);
    if (index > -1) {
        gameState.towers.splice(index, 1);
    }
    
    calculateNoise();
    updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
    cancelSellTower();
}

function cancelSellTower() {
    gameState.selectedTowerToSell = null;
    
    document.getElementById('overlay').classList.remove('active');
    document.getElementById('sellTowerModal').classList.remove('active');
}

function calculateNoise() {
    let autoFireCount = 0;
    for (const tower of gameState.towers) {
        if (!tower.requiresMath && !tower.isSupportTower) {
            autoFireCount++;
        }
    }
    
    let noisePerTower;
    if (gameState.difficulty === 'easy') {
        noisePerTower = 6;
    } else if (gameState.difficulty === 'normal') {
        noisePerTower = 7;
    } else {
        noisePerTower = 10;
    }
    
    gameState.noise = autoFireCount * noisePerTower;
    
    return gameState.noise;
}

function placeTower(scene, x, y, towerType) {
    const towerDef = TOWER_TYPES[towerType];
    
    const tower = {
        x, y,
        type: towerType,
        ...towerDef,
        lastFired: 0,
        level: 1,
        readyToFire: false,
        currentTarget: null,
        readyIndicator: null,
        scene: scene
    };
    
    // ‚úÖ USE ANIMATED SPRITE FOR BASIC TOWER
    if (towerType === 'basic' && scene.textures.exists('tower_basic_idle')) {
        console.log('‚úÖ Using animated sprite for basic tower');
        tower.graphic = scene.add.sprite(x, y, 'tower_basic_idle');
        tower.graphic.setScale(1.5);
        
        // Play idle animation
        if (scene.anims.exists('tower_basic_idle')) {
            tower.graphic.play('tower_basic_idle');
        }
    } else {
        // Fallback for other towers or if sprite not found
        const spriteKey = 'tower_' + towerType.replace('-', '_');
        if (scene.textures.exists(spriteKey)) {
            tower.graphic = scene.add.sprite(x, y, spriteKey);
            tower.graphic.setScale(1.0);
        } else {
            tower.graphic = scene.add.circle(x, y, 15, towerDef.color);
            tower.graphic.setStrokeStyle(2, 0x000000);
        }
    }
    
    if (towerDef.isSupportTower) {
        tower.auraGraphic = scene.add.circle(x, y, towerDef.auraRange, 0xff6600, 0);
        tower.auraGraphic.setStrokeStyle(3, 0xff6600, 0.3);
        
        scene.tweens.add({
            targets: tower.auraGraphic,
            alpha: { from: 0.1, to: 0.3 },
            scale: { from: 0.95, to: 1.05 },
            duration: 2000,
            yoyo: true,
            repeat: -1
        });
    }
    
    tower.rangeCircle = scene.add.circle(x, y, towerDef.range, 0x000000, 0);
    tower.rangeCircle.setStrokeStyle(2, 0xffffff, 0);
    
    tower.graphic.setInteractive({ useHandCursor: true });
    tower.graphic.on('pointerover', () => tower.rangeCircle.setAlpha(0.2));
    tower.graphic.on('pointerout', () => tower.rangeCircle.setAlpha(0));
    
    tower.graphic.on('pointerdown', (pointer, localX, localY, event) => {
        event.stopPropagation();
        
        if (gameState.sellMode) {
            showSellTowerModal(tower);
            return;
        }
        
        if (tower.requiresMath && tower.readyToFire && tower.currentTarget) {
            let timeLimit;
            if (gameState.difficulty === 'easy') {
                timeLimit = 30;
            } else if (gameState.difficulty === 'normal') {
                timeLimit = 20;
            } else {
                timeLimit = 15;
            }
            
            const problem = generateMathProblem(gameState.difficulty, tower.cost);
            const savedTarget = tower.currentTarget;
            
            showMathProblem(problem.question, timeLimit, (answered, answer) => {
                if (answered && answer === problem.answer) {
                    let goldReward = 0;
                    if (gameState.difficulty === 'easy') {
                        goldReward = 30;
                    } else if (gameState.difficulty === 'normal') {
                        goldReward = 75;
                    } else {
                        goldReward = 100;
                    }
                    
                    gameState.gold += goldReward;
                    gameState.totalProblemsCompleted++;
                    
                    checkTowerUnlocks(tower.scene);
                    
                    if (savedTarget && savedTarget.graphic && savedTarget.graphic.active) {
                        fireTower(tower.scene, tower, savedTarget);
                        
                        if (tower.scene && tower.scene.time) {
                            tower.lastFired = tower.scene.time.now;
                        } else {
                            tower.lastFired = 0;
                        }
                    }
                    
                    updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
                } else {
                    tower.lastFired = 0;
                }
                
                tower.readyToFire = false;
                tower.currentTarget = null;
                
                if (tower.readyIndicator) {
                    tower.readyIndicator.destroy();
                    tower.readyIndicator = null;
                }
            });
        } else {
            showSellTowerModal(tower);
        }
    });
    
    gameState.towers.push(tower);
    calculateNoise();
}

function generateMathProblem(difficulty, towerCost) {
    let num1, num2, operation, answer, question;
    
    const scale = Math.floor(towerCost / 50);
    const waveScale = 1 + (gameState.wave * 0.1);
    
    if (difficulty === 'easy') {
        if (Math.random() < 0.5) {
            if (Math.random() < 0.5 - (gameState.wave * 0.05)) {
                const maxDigit = Math.min(15, 9 + Math.floor(gameState.wave / 2));
                num1 = Math.floor(Math.random() * maxDigit) + 1;
                num2 = Math.floor(Math.random() * maxDigit) + 1;
            } else {
                const maxDigit = Math.min(15, 9 + Math.floor(gameState.wave / 2));
                num1 = Math.floor(Math.random() * maxDigit) + 1;
                num2 = (Math.floor(Math.random() * Math.min(5, 3 + Math.floor(gameState.wave / 3))) + 1) * 10;
            }
            answer = num1 + num2;
            question = `${num1} + ${num2} = ?`;
        } else {
            if (Math.random() < 0.5) {
                num1 = (Math.floor(Math.random() * Math.min(7, 3 + Math.floor(gameState.wave / 2))) + 1) * 10;
                num2 = Math.floor(Math.random() * Math.min(15, 9 + Math.floor(gameState.wave / 3))) + 1;
            } else {
                const maxDigit = Math.min(20, 9 + gameState.wave);
                num2 = Math.floor(Math.random() * maxDigit) + 1;
                num1 = num2 + Math.floor(Math.random() * maxDigit) + 1;
            }
            answer = num1 - num2;
            question = `${num1} - ${num2} = ?`;
        }
    } else if (difficulty === 'normal') {
        const rand = Math.random();
        if (rand < 0.33) {
            num1 = Math.floor(Math.random() * (15 * scale)) + scale;
            num2 = Math.floor(Math.random() * (15 * scale)) + scale;
            answer = num1 + num2;
            question = `${num1} + ${num2} = ?`;
        } else if (rand < 0.66) {
            num1 = Math.floor(Math.random() * (15 * scale)) + (15 * scale);
            num2 = Math.floor(Math.random() * (10 * scale)) + scale;
            answer = num1 - num2;
            question = `${num1} - ${num2} = ?`;
        } else {
            num1 = Math.floor(Math.random() * (5 * scale)) + scale;
            num2 = Math.floor(Math.random() * (5 * scale)) + scale;
            answer = num1 * num2;
            question = `${num1} √ó ${num2} = ?`;
        }
    } else {
        const rand = Math.random();
        if (rand < 0.4) {
            num1 = Math.floor(Math.random() * (8 * scale)) + scale;
            num2 = Math.floor(Math.random() * (8 * scale)) + scale;
            answer = num1 * num2;
            question = `${num1} √ó ${num2} = ?`;
        } else if (rand < 0.7) {
            num2 = Math.floor(Math.random() * (8 * scale)) + scale;
            answer = Math.floor(Math.random() * (10 * scale)) + scale;
            num1 = answer * num2;
            question = `${num1} √∑ ${num2} = ?`;
        } else {
            num1 = Math.floor(Math.random() * (30 * scale)) + (20 * scale);
            num2 = Math.floor(Math.random() * (20 * scale)) + scale;
            answer = num1 - num2;
            question = `${num1} - ${num2} = ?`;
        }
    }
    
    return { question, answer };
}

function isOnPath(x, y) {
    for (let i = 0; i < gameState.path.length - 1; i++) {
        const p1 = gameState.path[i];
        const p2 = gameState.path[i + 1];
        const dist = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
        if (dist < 40) return true;
    }
    return false;
}

function distanceToLineSegment(x, y, x1, y1, x2, y2) {
    const A = x - x1;
    const B = y - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = lenSq !== 0 ? dot / lenSq : -1;
    
    let xx, yy;
    if (param < 0) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }
    
    const dx = x - xx;
    const dy = y - yy;
    return Math.sqrt(dx * dx + dy * dy);
}

function startWave(scene) {
    gameState.wave++;
    updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
    
    const baseEnemyCount = 3 + gameState.wave * 2;
    const difficultyMultiplier = {
        'easy': 0.8,
        'normal': 1.0,
        'hard': 1.2
    }[gameState.difficulty];
    
    const isBossWave = gameState.wave % 5 === 0;
    const enemyCount = Math.floor(baseEnemyCount * difficultyMultiplier) + (isBossWave ? 1 : 0);
    
    gameState.totalEnemiesToSpawn = enemyCount;
    gameState.enemiesSpawnedThisWave = 0;
    
    if (scene.waveButton && scene.waveText) {
        scene.waveButton.disableInteractive();
        scene.waveButton.setFillStyle(0x666666);
        scene.waveText.setText(isBossWave ? 'BOSS WAVE!' : 'Wave in Progress...');
        scene.waveText.setColor(isBossWave ? '#ff00ff' : '#aaaaaa');
    }
    
    const fastEnemyChance = Math.min(0.4, 0.2 + (gameState.wave * 0.03));
    const tankChance = gameState.wave > 2 ? Math.min(0.2, 0.05 * (gameState.wave - 2)) : 0;
    
    let enemiesSpawned = 0;
    const regularEnemyCount = isBossWave ? enemyCount - 1 : enemyCount;
    
    scene.time.addEvent({
        delay: 1000,
        repeat: regularEnemyCount - 1,
        callback: () => {
            let enemyType = 'basic';
            const rand = Math.random();
            
            if (rand < tankChance && gameState.wave > 2) {
                enemyType = 'tank';
            } else if (rand < tankChance + fastEnemyChance) {
                enemyType = 'fast';
            }
            
            spawnEnemy(scene, enemyType);
            enemiesSpawned++;
        }
    });
    
    if (isBossWave) {
        scene.time.addEvent({
            delay: 1000 * (regularEnemyCount + 2),
            callback: () => {
                spawnEnemy(scene, 'boss');
            }
        });
    }
}

function showGameOver(scene) {
    gameState.gameOver = true;
    
    document.getElementById('finalScore').textContent = gameState.score;
    document.getElementById('finalWave').textContent = gameState.wave;
    document.getElementById('finalEnemies').textContent = gameState.enemiesDefeated;
    
    document.getElementById('overlay').classList.add('active');
    document.getElementById('gameOverModal').classList.add('active');
    
    if (scene.waveButton && scene.waveText) {
        scene.waveButton.setFillStyle(0x666666);
        scene.waveButton.disableInteractive();
        scene.waveText.setText('Game Over');
        scene.waveText.setColor('#ff6b6b');
    }
}

function spawnEnemy(scene, type = 'basic') {
    const enemyDef = ENEMY_TYPES[type];
    
    const speedMultiplier = Math.min(2.0, 1 + (gameState.wave * 0.05));
    const healthMultiplier = Math.min(3.0, 1 + (gameState.wave * 0.10));
    
    const enemy = {
        type,
        health: Math.floor(enemyDef.health * healthMultiplier),
        maxHealth: Math.floor(enemyDef.health * healthMultiplier),
        speed: enemyDef.baseSpeed * speedMultiplier,
        gold: enemyDef.gold,
        isBoss: enemyDef.isBoss || false,
        pathIndex: 0,
        x: gameState.path[0].x,
        y: gameState.path[0].y,
        slowEffect: 1
    };
    
    const spriteKey = 'enemy_' + type;
    if (scene.textures.exists(spriteKey)) {
        enemy.graphic = scene.add.sprite(enemy.x, enemy.y, spriteKey);
        
        const animKey = spriteKey + '_walk';
        if (scene.anims.exists(animKey)) {
            enemy.graphic.play(animKey);
        }
        
        if (enemy.isBoss) {
            enemy.graphic.setScale(1.2);
        } else {
            enemy.graphic.setScale(1.0);
        }
    } else {
        const size = enemy.isBoss ? 15 : 8;
        enemy.graphic = scene.add.circle(enemy.x, enemy.y, size, enemyDef.color);
        enemy.graphic.setStrokeStyle(enemy.isBoss ? 4 : 2, 0x000000);
    }
    
    if (enemy.isBoss) {
        enemy.crownText = scene.add.text(enemy.x, enemy.y - 25, 'üëë', {
            fontSize: '20px'
        }).setOrigin(0.5);
    }
    
    const healthBarWidth = enemy.isBoss ? 40 : 20;
    enemy.healthBarBg = scene.add.rectangle(enemy.x, enemy.y - 15, healthBarWidth, 3, 0x000000);
    enemy.healthBar = scene.add.rectangle(enemy.x, enemy.y - 15, healthBarWidth, 3, 0x00ff00);
    
    gameState.enemies.push(enemy);
    gameState.enemiesSpawnedThisWave++;
}

function update(time, delta) {
    if (gameState.gameOver) return;
    
    if (gameState.health <= 0) {
        showGameOver(this);
        return;
    }
    
    // Update enemies
    for (let i = gameState.enemies.length - 1; i >= 0; i--) {
        const enemy = gameState.enemies[i];
        
        if (enemy.pathIndex < gameState.path.length - 1) {
            const target = gameState.path[enemy.pathIndex + 1];
            const dx = target.x - enemy.x;
            const dy = target.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 5) {
                enemy.pathIndex++;
            } else {
                const speed = (enemy.speed * delta) / 1000;
                enemy.x += (dx / distance) * speed;
                enemy.y += (dy / distance) * speed;
                
                enemy.graphic.setPosition(enemy.x, enemy.y);
                enemy.healthBarBg.setPosition(enemy.x, enemy.y - 15);
                enemy.healthBar.setPosition(enemy.x, enemy.y - 15);
                
                if (enemy.crownText) {
                    enemy.crownText.setPosition(enemy.x, enemy.y - 25);
                }
            }
        } else {
            gameState.health -= 10;
            updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
            
            if (gameState.base && gameState.base.healthBar) {
                const healthPercent = gameState.health / 100;
                gameState.base.healthBar.setScale(healthPercent, 1);
                
                if (healthPercent < 0.3) {
                    gameState.base.healthBar.setFillStyle(0xff0000);
                } else if (healthPercent < 0.6) {
                    gameState.base.healthBar.setFillStyle(0xffff00);
                }
            }
            
            enemy.graphic.destroy();
            enemy.healthBarBg.destroy();
            enemy.healthBar.destroy();
            if (enemy.crownText) enemy.crownText.destroy();
            gameState.enemies.splice(i, 1);
            
            if (gameState.health <= 0) {
                showGameOver(this);
                return;
            }
        }
    }
    
    // Update towers
    for (const tower of gameState.towers) {
        if (!tower.requiresMath && !tower.isSupportTower && gameState.noise >= 45) {
            if (!tower.noiseWarning) {
                tower.noiseWarning = this.add.graphics();
                tower.noiseWarning.lineStyle(2, 0xff0000, 0.5);
                tower.noiseWarning.strokeCircle(0, 0, 20);
                tower.noiseWarning.setPosition(tower.x, tower.y);
                
                this.tweens.add({
                    targets: tower.noiseWarning,
                    alpha: { from: 0.3, to: 0.8 },
                    scale: { from: 0.95, to: 1.1 },
                    duration: 1000,
                    yoyo: true,
                    repeat: -1
                });
            }
            
            if (gameState.noise >= 50 && Math.random() < 0.1) {
                if (tower.graphic) {
                    const originalTint = tower.graphic.tintTopLeft || 0xffffff;
                    tower.graphic.setTint(0xff0000);
                    this.time.delayedCall(50, () => {
                        if (tower.graphic) tower.graphic.setTint(originalTint);
                    });
                }
            }
        } else if (tower.noiseWarning) {
            tower.noiseWarning.destroy();
            tower.noiseWarning = null;
        }
        
        if (tower.isSupportTower) {
            continue;
        }
        
        if (time - tower.lastFired > tower.fireRate) {
            const target = findEnemyInRange(tower);
            
            if (target) {
                if (tower.requiresMath) {
                    const hasSupportAura = checkForSupportAura(tower);
                    const shouldAutoFire = hasSupportAura && target.isBoss;
                    
                    if (shouldAutoFire) {
                        fireTower(this, tower, target);
                        tower.lastFired = time;
                        
                        if (tower.readyIndicator) {
                            tower.readyIndicator.destroy();
                            tower.readyIndicator = null;
                        }
                        tower.readyToFire = false;
                        tower.currentTarget = null;
                    } else {
                        if (!tower.readyIndicator) {
                            tower.readyIndicator = this.add.circle(tower.x, tower.y, 20, 0xffff00, 0);
                            tower.readyIndicator.setStrokeStyle(3, 0xffff00, 0.8);
                            
                            this.tweens.add({
                                targets: tower.readyIndicator,
                                alpha: { from: 0.3, to: 0.8 },
                                scale: { from: 0.9, to: 1.1 },
                                duration: 500,
                                yoyo: true,
                                repeat: -1
                            });
                        }
                        tower.currentTarget = target;
                        tower.readyToFire = true;
                    }
                } else {
                    fireTower(this, tower, target);
                    tower.lastFired = time;
                }
            } else {
                if (tower.readyIndicator) {
                    tower.readyIndicator.destroy();
                    tower.readyIndicator = null;
                }
                tower.readyToFire = false;
                tower.currentTarget = null;
            }
        }
    }
    
    // Update projectiles
    for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
        const proj = gameState.projectiles[i];
        
        if (proj.x < -50 || proj.x > 850 || proj.y < -50 || proj.y > 650) {
            proj.graphic.destroy();
            gameState.projectiles.splice(i, 1);
            continue;
        }
        
        if (proj.missed) {
            const speed = (400 * delta) / 1000;
            proj.x += proj.missVelocityX * speed;
            proj.y += proj.missVelocityY * speed;
            proj.graphic.setPosition(proj.x, proj.y);
            
            if (proj.graphic.alpha > 0.1) {
                proj.graphic.setAlpha(proj.graphic.alpha - 0.02);
            }
            continue;
        }
        
        if (proj.target && proj.target.graphic && proj.target.graphic.active) {
            const dx = proj.target.x - proj.x;
            const dy = proj.target.y - proj.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 10) {
                let missed = false;
                if (proj.isAutoFire && gameState.noise >= 50) {
                    const missChance = Math.min(0.5, (gameState.noise - 50) / 100 + 0.2);
                    missed = Math.random() < missChance;
                    
                    if (missed) {
                        proj.missed = true;
                        
                        const missAngleOffset = (Math.random() - 0.5) * Math.PI;
                        const currentAngle = Math.atan2(dy, dx);
                        const missAngle = currentAngle + missAngleOffset;
                        
                        proj.missVelocityX = Math.cos(missAngle) * 1.5;
                        proj.missVelocityY = Math.sin(missAngle) * 1.5;
                        
                        if (proj.graphic.type === 'Sprite') {
                            proj.graphic.setTint(0xff3333);
                        } else {
                            proj.graphic.setFillStyle(0xff3333);
                        }
                        
                        const missText = this.add.text(proj.x, proj.y - 10, 'MISS!', {
                            fontSize: '12px',
                            color: '#ff0000',
                            fontStyle: 'bold',
                            stroke: '#ffffff',
                            strokeThickness: 2
                        }).setOrigin(0.5);
                        
                        this.tweens.add({
                            targets: missText,
                            y: missText.y - 20,
                            alpha: 0,
                            duration: 500,
                            onComplete: () => missText.destroy()
                        });
                        
                        if (!this.cameras.main.shakeEffect.isRunning) {
                            this.cameras.main.shake(100, 0.002);
                        }
                        
                        for (let p = 0; p < 3; p++) {
                            const particle = this.add.circle(
                                proj.x + (Math.random() - 0.5) * 10, 
                                proj.y + (Math.random() - 0.5) * 10, 
                                2, 
                                0xff3333
                            );
                            
                            const pAngle = Math.random() * Math.PI * 2;
                            const pSpeed = 50 + Math.random() * 50;
                            
                            this.tweens.add({
                                targets: particle,
                                x: particle.x + Math.cos(pAngle) * pSpeed,
                                y: particle.y + Math.sin(pAngle) * pSpeed,
                                alpha: 0,
                                duration: 300,
                                onComplete: () => particle.destroy()
                            });
                        }
                        
                        continue;
                    }
                }
                
                damageEnemy(proj.target, proj.damage);
                proj.graphic.destroy();
                gameState.projectiles.splice(i, 1);
            } else {
                const speed = (300 * delta) / 1000;
                proj.x += (dx / distance) * speed;
                proj.y += (dy / distance) * speed;
                proj.graphic.setPosition(proj.x, proj.y);
                
                if (proj.graphic.type === 'Sprite') {
                    const angle = Phaser.Math.Angle.Between(proj.x, proj.y, proj.target.x, proj.target.y);
                    proj.graphic.setRotation(angle);
                }
            }
        } else {
            proj.graphic.destroy();
            gameState.projectiles.splice(i, 1);
        }
    }
    
    // Check wave complete
    if (gameState.waveInProgress && 
        gameState.enemiesSpawnedThisWave >= gameState.totalEnemiesToSpawn && 
        gameState.enemies.length === 0) {
        gameState.waveInProgress = false;
        
        let waveBonus = 100;
        if (gameState.difficulty === 'easy') {
            waveBonus = 50;
        } else if (gameState.difficulty === 'normal') {
            waveBonus = 75;
        } else {
            waveBonus = 100;
        }
        gameState.gold += waveBonus;
        
        updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
        
        if (this.waveButton && this.waveText) {
            this.waveButton.setFillStyle(0x00aa00);
            this.waveButton.setInteractive({ useHandCursor: true });
            this.waveText.setText('Start Wave ' + (gameState.wave + 1));
            this.waveText.setColor('#ffffff');
        }
    }
}

function findEnemyInRange(tower) {
    for (const enemy of gameState.enemies) {
        const dx = enemy.x - tower.x;
        const dy = enemy.y - tower.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance <= tower.range) return enemy;
    }
    return null;
}

function checkForSupportAura(tower) {
    for (const supportTower of gameState.towers) {
        if (supportTower.isSupportTower) {
            const dx = tower.x - supportTower.x;
            const dy = tower.y - supportTower.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= supportTower.auraRange) {
                return true;
            }
        }
    }
    return false;
}

function fireTower(scene, tower, target) {
    console.log('üî´ Firing tower:', tower.type);
    
    // ‚úÖ PLAY FIRE ANIMATION FOR BASIC TOWER
    if (tower.type === 'basic' && tower.graphic && tower.graphic.anims) {
        if (scene.anims.exists('tower_basic_shoot')) {
            tower.graphic.play('tower_basic_shoot');
            
            // Return to idle after animation
            tower.graphic.once('animationcomplete', () => {
                if (scene.anims.exists('tower_basic_idle')) {
                    tower.graphic.play('tower_basic_idle');
                }
            });
        }
    }
    
    const projectile = {
        x: tower.x,
        y: tower.y,
        target: target,
        damage: tower.damage,
        isAutoFire: !tower.requiresMath && !tower.isSupportTower
    };
    
    if (scene.textures.exists('projectile')) {
        projectile.graphic = scene.add.sprite(tower.x, tower.y, 'projectile');
        projectile.graphic.setScale(0.5);
        
        const angle = Phaser.Math.Angle.Between(tower.x, tower.y, target.x, target.y);
        projectile.graphic.setRotation(angle);
    } else {
        projectile.graphic = scene.add.circle(tower.x, tower.y, 4, 0xffff00);
    }
    
    gameState.projectiles.push(projectile);
}

function damageEnemy(enemy, damage) {
    enemy.health -= damage;
    const healthPercent = enemy.health / enemy.maxHealth;
    enemy.healthBar.setScale(healthPercent, 1);
    
    if (healthPercent < 0.3) {
        enemy.healthBar.setFillStyle(0xff0000);
    } else if (healthPercent < 0.6) {
        enemy.healthBar.setFillStyle(0xffff00);
    }
    
    if (enemy.health <= 0) {
        gameState.gold += enemy.gold;
        gameState.score += enemy.gold * 5;
        gameState.enemiesDefeated++;
        updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
        
        enemy.graphic.destroy();
        enemy.healthBarBg.destroy();
        enemy.healthBar.destroy();
        if (enemy.crownText) enemy.crownText.destroy();
        
        const index = gameState.enemies.indexOf(enemy);
        if (index > -1) gameState.enemies.splice(index, 1);
    }
}
    </script>
</body>
</html>
