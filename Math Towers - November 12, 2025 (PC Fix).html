<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Tower Defense</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: manipulation; /* Prevent zoom on double-tap */
            -webkit-user-select: none; /* Prevent text selection on mobile */
            user-select: none;
        }

        /* Main Menu */
        .menu-container {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .menu-container.hidden {
            display: none;
        }

        .game-title {
            font-size: 36px;
            color: #667eea;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .game-subtitle {
            font-size: 16px;
            color: #666;
            margin-bottom: 30px;
        }

        .menu-section {
            margin: 30px 0;
        }

        .menu-section h3 {
            font-size: 20px;
            color: #333;
            margin-bottom: 15px;
        }

        .difficulty-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .difficulty-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
        }

        .difficulty-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .difficulty-btn.selected {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            box-shadow: 0 5px 15px rgba(67, 233, 123, 0.4);
        }

        .start-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 20px 50px;
            font-size: 24px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
            font-weight: bold;
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(245, 87, 108, 0.4);
        }

        .instructions {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            text-align: left;
            margin: 20px 0;
        }

        .instructions h3 {
            text-align: center;
            margin-bottom: 15px;
        }

        .instructions ul {
            list-style-position: inside;
            color: #555;
            line-height: 1.8;
        }

        .instructions li {
            margin: 8px 0;
        }

        .difficulty-info {
            background: #fff3cd;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }

        .difficulty-info p {
            color: #856404;
            margin: 5px 0;
            font-size: 14px;
        }

        /* Game Container (hidden initially) */
        #game-container {
            display: none;
            border-radius: 10px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            background: #000;
            max-width: 100%;
            margin: 0 auto;
        }

        #game-container.active {
            display: block;
        }

        /* Mobile optimizations */
        @media (max-width: 850px) {
            #game-container {
                border-radius: 0;
                margin: 0;
            }
            
            .game-hud {
                font-size: 14px;
                padding: 8px 15px;
                gap: 15px;
            }
            
            .hud-value {
                font-size: 16px;
            }
        }

        /* Math Problem Modal */
        .math-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            text-align: center;
            min-width: 350px;
        }

        .math-modal.active {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .math-question {
            font-size: 24px;
            color: #333;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .math-timer {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 18px;
            color: #667eea;
            font-weight: bold;
        }

        .math-input {
            width: 100%;
            padding: 12px;
            font-size: 20px;
            border: 2px solid #667eea;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
        }

        .math-submit {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .math-submit:hover {
            transform: scale(1.05);
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        .overlay.active {
            display: block;
        }

        /* Game HUD */
        .game-hud {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            color: white;
            display: none;
            gap: 20px;
            z-index: 100;
        }

        .game-hud.active {
            display: flex;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .hud-value {
            color: #fff;
            font-size: 18px;
            font-weight: bold;
        }

        .hud-gold { color: #ffd700; }
        .hud-health { color: #ff6b6b; }
        .hud-wave { color: #4ecdc4; }
        .hud-score { color: #a8e6cf; }
        .hud-noise { color: #ffaa00; }

        /* Game Over Modal */
        .game-over-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            text-align: center;
            min-width: 400px;
        }

        .game-over-modal.active {
            display: block;
            animation: slideIn 0.3s ease;
        }

        .game-over-title {
            font-size: 48px;
            color: #ff6b6b;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .game-over-stats {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .game-over-stat {
            font-size: 20px;
            color: #333;
            margin: 10px 0;
        }

        .game-over-stat strong {
            color: #667eea;
        }

        .restart-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        /* Mobile Cancel Button */
        .cancel-placement-btn {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 10px;
            cursor: pointer;
            z-index: 200;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
            font-weight: bold;
        }

        .cancel-placement-btn.active {
            display: block;
            animation: slideUp 0.3s ease;
        }

        /* Mobile Confirm Button */
        .confirm-placement-btn {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 10px;
            cursor: pointer;
            z-index: 200;
            box-shadow: 0 5px 15px rgba(67, 233, 123, 0.4);
            font-weight: bold;
        }

        .confirm-placement-btn.active {
            display: block;
            animation: slideUp 0.3s ease;
        }

        /* Button container for placement controls */
        .placement-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            gap: 15px;
            z-index: 200;
        }

        .placement-controls.active {
            display: flex;
        }

        .placement-controls button {
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .placement-controls .confirm-btn {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
        }

        .placement-controls .cancel-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
        }

        .placement-controls button:active {
            transform: scale(0.95);
        }

        /* Tower Sell Modal */
        .sell-tower-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            text-align: center;
            min-width: 300px;
        }

        .sell-tower-modal.active {
            display: block;
            animation: slideIn 0.3s ease;
        }

        .sell-tower-title {
            font-size: 24px;
            color: #333;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .sell-tower-info {
            font-size: 18px;
            color: #666;
            margin-bottom: 20px;
        }

        .sell-tower-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .sell-tower-buttons button {
            padding: 12px 25px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
        }

        .sell-confirm-btn {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
        }

        .sell-cancel-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        .cancel-placement-btn:active {
            transform: translateX(-50%) scale(0.95);
        }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div class="menu-container" id="mainMenu">
        <h1 class="game-title">üè∞ Math Tower Defense</h1>
        <p class="game-subtitle">Defend your base by solving math problems!</p>

        <div class="menu-section">
            <h3>Select Difficulty</h3>
            <div class="difficulty-buttons">
                <button class="difficulty-btn" data-difficulty="easy" onclick="selectDifficulty('easy')">
                    Easy
                </button>
                <button class="difficulty-btn selected" data-difficulty="normal" onclick="selectDifficulty('normal')">
                    Normal
                </button>
                <button class="difficulty-btn" data-difficulty="hard" onclick="selectDifficulty('hard')">
                    Hard
                </button>
            </div>
            
            <div class="difficulty-info" id="difficultyInfo">
                <p><strong>Normal:</strong> Addition, Subtraction & Multiplication | 30 seconds per problem</p>
            </div>
        </div>

        <div class="instructions">
            <h3>How to Play</h3>
            <ul>
                <li><strong>Earn Gold:</strong> Solve math (Easy: 50g, Normal: 75g, Hard: 100g) + Kill enemies (10-100g) + Complete waves (100g)</li>
                <li><strong>Place Towers:</strong> Tap tower button ‚Üí Position on map ‚Üí Tap ‚úÖ Confirm ‚Üí Solve math (costs: Basic 100g, Math Archer 150g, Support 200g)</li>
                <li><strong>Enemy Types:</strong> üü¢ Basic (slow), üü° Fast (quick but weak), üî¥ Tank (tough), üëë Boss (every 5 waves)</li>
                <li><strong>Noise Meter:</strong> ‚ö†Ô∏è Auto-fire towers add noise (3%/5%/8% per tower on Easy/Normal/Hard). At 50%+ noise, shots start missing!</li>
                <li><strong>Placement:</strong> After selecting a tower, tap to position ‚Üí Tap ‚úÖ Confirm (or press Enter on PC) to solve math and place, or ‚ùå Cancel (C/ESC) to cancel</li>
                <li><strong>Basic Tower:</strong> Fires automatically (no math required)</li>
                <li><strong>Math Towers:</strong> Glow yellow when ready - click them to solve math and fire!</li>
                <li><strong>Sell Towers:</strong> Tap any tower (that's not ready to fire) to sell it back for 50% of its cost</li>
                <li><strong>Bosses:</strong> üëë Powerful enemies appear every 5 waves!</li>
                <li><strong>Support Aura:</strong> Unlock by solving 10+ problems on Easy - Makes nearby math towers auto-fire at bosses!</li>
                <li><strong>Defend:</strong> Stop enemies from reaching your base!</li>
            </ul>
        </div>

        <button class="start-btn" onclick="startGame()">
            Start Game
        </button>
    </div>
    
    <div id="game-container"></div>
    
    <!-- Math Problem Modal -->
    <div class="overlay" id="overlay"></div>
    <div class="math-modal" id="mathModal">
        <div class="math-timer" id="mathTimer">10s</div>
        <div class="math-question" id="mathQuestion">5 + 3 = ?</div>
        <input type="number" class="math-input" id="mathInput" autofocus>
        <button class="math-submit" onclick="submitAnswer()">Submit Answer</button>
    </div>

    <!-- Game HUD -->
    <div class="game-hud" id="gameHud">
        <div class="hud-item">
            <span>Gold:</span>
            <span class="hud-value hud-gold" id="hudGold">0</span>
        </div>
        <div class="hud-item">
            <span>Health:</span>
            <span class="hud-value hud-health" id="hudHealth">100</span>
        </div>
        <div class="hud-item">
            <span>Wave:</span>
            <span class="hud-value hud-wave" id="hudWave">0</span>
        </div>
        <div class="hud-item">
            <span>Score:</span>
            <span class="hud-value hud-score" id="hudScore">0</span>
        </div>
        <div class="hud-item">
            <span>Noise:</span>
            <span class="hud-value hud-noise" id="hudNoise">0%</span>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="game-over-modal" id="gameOverModal">
        <h1 class="game-over-title">Game Over!</h1>
        <div class="game-over-stats">
            <div class="game-over-stat">
                <strong>Final Score:</strong> <span id="finalScore">0</span>
            </div>
            <div class="game-over-stat">
                <strong>Waves Completed:</strong> <span id="finalWave">0</span>
            </div>
            <div class="game-over-stat">
                <strong>Enemies Defeated:</strong> <span id="finalEnemies">0</span>
            </div>
        </div>
        <button class="restart-btn" onclick="restartGame()">Play Again</button>
    </div>

    <!-- Cancel Tower Placement Button (Mobile) -->
    <button class="cancel-placement-btn" id="cancelPlacementBtn" onclick="cancelTowerPlacement()">
        ‚ùå Cancel Tower
    </button>

    <!-- Placement Controls (Mobile) -->
    <div class="placement-controls" id="placementControls">
        <button class="confirm-btn" onclick="confirmTowerPlacement()">
            ‚úÖ Confirm
        </button>
        <button class="cancel-btn" onclick="cancelTowerPlacement()">
            ‚ùå Cancel
        </button>
    </div>

    <!-- Sell Tower Modal -->
    <div class="sell-tower-modal" id="sellTowerModal">
        <h2 class="sell-tower-title">Sell Tower?</h2>
        <p class="sell-tower-info" id="sellTowerInfo">Sell for 50g?</p>
        <div class="sell-tower-buttons">
            <button class="sell-confirm-btn" onclick="confirmSellTower()">
                üí∞ Sell
            </button>
            <button class="sell-cancel-btn" onclick="cancelSellTower()">
                ‚ùå Cancel
            </button>
        </div>
    </div>

    <!-- Load Phaser 3 from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    
    <!-- Shared variables -->
    <script>
        // Game settings
        let selectedDifficulty = 'normal';
        let gameStarted = false;

        // Difficulty selection
        function selectDifficulty(difficulty) {
            selectedDifficulty = difficulty;
            
            // Update button states
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.dataset.difficulty === difficulty) {
                    btn.classList.add('selected');
                }
            });
            
            // Update difficulty info
            const info = {
                easy: '<p><strong>Easy:</strong> Addition & Subtraction only | 60 seconds per problem</p>',
                normal: '<p><strong>Normal:</strong> Addition, Subtraction & Multiplication | 30 seconds per problem</p>',
                hard: '<p><strong>Hard:</strong> Multiplication, Division & Subtraction | 20 seconds per problem</p>'
            };
            
            document.getElementById('difficultyInfo').innerHTML = info[difficulty];
        }

        // Start the game
        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            
            // Hide menu, show game
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('game-container').classList.add('active');
            document.getElementById('gameHud').classList.add('active');
            
            // NOW create the Phaser game with the selected difficulty
            console.log('Creating game with selected difficulty:', selectedDifficulty);
            game = new Phaser.Game(config);
        }

        // Math modal functions
        let currentMathCallback = null;
        let mathTimer = null;
        let timeLeft = 10;

        function showMathProblem(question, timeLimit, callback) {
            currentMathCallback = callback;
            timeLeft = timeLimit || 10;
            
            document.getElementById('mathQuestion').textContent = question;
            document.getElementById('mathInput').value = '';
            document.getElementById('mathTimer').textContent = timeLeft + 's';
            
            document.getElementById('overlay').classList.add('active');
            document.getElementById('mathModal').classList.add('active');
            
            document.getElementById('mathInput').focus();
            
            // Start timer
            mathTimer = setInterval(() => {
                timeLeft--;
                document.getElementById('mathTimer').textContent = timeLeft + 's';
                
                if (timeLeft <= 0) {
                    closeMathModal(false);
                }
            }, 1000);
        }

        function submitAnswer() {
            const answer = parseFloat(document.getElementById('mathInput').value);
            if (!isNaN(answer)) {
                closeMathModal(true, answer);
            }
        }

        function closeMathModal(answered, answer) {
            clearInterval(mathTimer);
            
            document.getElementById('overlay').classList.remove('active');
            document.getElementById('mathModal').classList.remove('active');
            
            if (currentMathCallback) {
                currentMathCallback(answered, answer);
                currentMathCallback = null;
            }
        }

        // Allow Enter key to submit
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('mathInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitAnswer();
                }
            });
        });

        // Update HUD
        function updateHUD(gold, health, wave, score, noise) {
            document.getElementById('hudGold').textContent = gold;
            document.getElementById('hudHealth').textContent = health;
            document.getElementById('hudWave').textContent = wave;
            document.getElementById('hudScore').textContent = score;
            
            // Update noise meter with color coding
            const noiseElement = document.getElementById('hudNoise');
            noiseElement.textContent = Math.round(noise) + '%';
            
            // Change color based on noise level
            if (noise >= 50) {
                noiseElement.style.color = '#ff0000'; // Red when affecting accuracy
            } else if (noise >= 35) {
                noiseElement.style.color = '#ff9900'; // Orange as warning
            } else {
                noiseElement.style.color = '#00ff00'; // Green when safe
            }
        }

        function showHUD() {
            document.getElementById('gameHud').classList.add('active');
        }

        function hideHUD() {
            document.getElementById('gameHud').classList.remove('active');
        }

        // Restart game function
        function restartGame() {
            // Hide game over modal
            document.getElementById('gameOverModal').classList.remove('active');
            document.getElementById('overlay').classList.remove('active');
            
            // Destroy current game
            if (game) {
                game.destroy(true);
            }
            
            // Reset game started flag
            gameStarted = false;
            
            // Show menu again
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('game-container').classList.remove('active');
            document.getElementById('gameHud').classList.remove('active');
        }
    </script>
    
    <!-- Game Code -->
    <script>
// Math Tower Defense - Game Code
const config = {
    type: Phaser.AUTO,
    scale: {
        mode: Phaser.Scale.FIT,
        parent: 'game-container',
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: 800,
        height: 600
    },
    backgroundColor: '#2d5016',
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

// Game will be created when user clicks Start Game
let game = null;

// Game state
let gameState = {
    gold: 150,  // Starting gold for first tower
    health: 100,
    wave: 0,
    score: 0,
    difficulty: 'normal',
    towers: [],
    enemies: [],
    projectiles: [],
    selectedTowerType: null,
    isPlacingTower: false,
    waveInProgress: false,
    gameOver: false,
    enemiesDefeated: 0,
    enemiesSpawnedThisWave: 0,
    totalEnemiesToSpawn: 0,
    totalProblemsCompleted: 0,
    noise: 0,  // Noise meter percentage (0-100)
    path: [],
    unlockedTowers: ['basic', 'math-archer'],
    base: null,
    preview: {
        tower: null,
        range: null,
        cost: null
    },
    pendingPlacement: null,
    sellMode: false,
    selectedTowerToSell: null,
    mathProblemsCompleted: {
        addition: 0,
        multiplication: 0,
        division: 0
    }
};

// Tower types
const TOWER_TYPES = {
    'basic': {
        name: 'Basic Tower',
        cost: 100,
        damage: 10,
        range: 120,
        fireRate: 1000,
        color: 0x808080,
        requiresMath: false,
        description: 'Auto-fires at enemies'
    },
    'math-archer': {
        name: 'Math Archer',
        cost: 150,
        damage: 25,
        range: 150,
        fireRate: 1200,
        color: 0x0066ff,
        requiresMath: true,
        description: 'Click when ready to solve math and fire'
    },
    'math-cannon': {
        name: 'Support Aura',
        cost: 200,
        damage: 0,
        range: 180,
        fireRate: 0,
        color: 0xff6600,
        requiresMath: false,
        isSupportTower: true,
        auraRange: 180,
        description: 'Makes nearby math towers auto-fire at bosses!',
        unlockRequirement: { difficulty: 'easy', problems: 10 }
    }
};

// Enemy types
const ENEMY_TYPES = {
    'basic': { health: 30, speed: 50, gold: 10, color: 0x00ff00 },
    'fast': { health: 20, speed: 80, gold: 15, color: 0xffff00 },
    'tank': { health: 80, speed: 30, gold: 25, color: 0xff0000 },
    'boss': { health: 200, speed: 25, gold: 100, color: 0xff00ff, isBoss: true }
};

function createEnemyAnimations(scene) {
    // Create walking animations for each enemy type
    // Only create if the texture exists (sprite loaded successfully)

    if (scene.textures.exists('enemy_basic')) {
        scene.anims.create({
            key: 'enemy_basic_walk',
            frames: scene.anims.generateFrameNumbers('enemy_basic', { start: 0, end: 3 }),
            frameRate: 8,
            repeat: -1
        });
    }

    if (scene.textures.exists('enemy_fast')) {
        scene.anims.create({
            key: 'enemy_fast_walk',
            frames: scene.anims.generateFrameNumbers('enemy_fast', { start: 0, end: 3 }),
            frameRate: 12, // Faster animation for fast enemies
            repeat: -1
        });
    }

    if (scene.textures.exists('enemy_tank')) {
        scene.anims.create({
            key: 'enemy_tank_walk',
            frames: scene.anims.generateFrameNumbers('enemy_tank', { start: 0, end: 3 }),
            frameRate: 6, // Slower animation for tanks
            repeat: -1
        });
    }

    if (scene.textures.exists('enemy_boss')) {
        scene.anims.create({
            key: 'enemy_boss_walk',
            frames: scene.anims.generateFrameNumbers('enemy_boss', { start: 0, end: 3 }),
            frameRate: 6,
            repeat: -1
        });
    }

    console.log('Enemy animations created');
}

function createTowerAnimations(scene) {
    // Create basic tower animations

    // Idle animation (just use the single idle frame)
    if (scene.textures.exists('tower_basic_idle')) {
        console.log('√¢≈ì‚Äú tower_basic_idle texture loaded');
        scene.anims.create({
            key: 'tower_basic_idle',
            frames: [{ key: 'tower_basic_idle' }],
            frameRate: 1,
            repeat: -1
        });
    } else {
        console.warn('√¢≈ì‚Äî tower_basic_idle texture NOT found');
    }

    // Fire animation (19 frames)
    const fireFrames = [];
    for (let i = 1; i <= 19; i++) {
        if (scene.textures.exists(`tower_basic_fire_${i}`)) {
            fireFrames.push({ key: `tower_basic_fire_${i}` });
        }
    }

    console.log(`Loaded ${fireFrames.length}/19 fire animation frames`);

    if (fireFrames.length > 0) {
        scene.anims.create({
            key: 'tower_basic_fire',
            frames: fireFrames,
            frameRate: 20, // 20 frames per second for smooth animation
            repeat: 0 // Play once, then return to idle
        });
    }

    console.log('Tower animations created');
}

function preload() {
    // Load basic tower idle sprite
    this.load.image('tower_basic_idle', 'sprites/BasicTowerIdle.png');

    // Load basic tower fire animation frames (19 frames)
    for (let i = 1; i <= 19; i++) {
        const frameNum = i.toString().padStart(4, '0');
        this.load.image(`tower_basic_fire_${i}`, `sprites/sprites${frameNum}.png`);
    }

    // Load other tower sprites
    this.load.image('tower_math_archer', 'sprites/tower_math_archer.png');
    this.load.image('tower_support', 'sprites/tower_support.png');

    // Load enemy sprite sheets (for animations)
    // Each sprite sheet should have frames laid out horizontally
    // Frame size: 32x32 pixels, 4 frames for walking animation
    this.load.spritesheet('enemy_basic', 'sprites/enemy_basic.png', { frameWidth: 32, frameHeight: 32 });
    this.load.spritesheet('enemy_fast', 'sprites/enemy_fast.png', { frameWidth: 32, frameHeight: 32 });
    this.load.spritesheet('enemy_tank', 'sprites/enemy_tank.png', { frameWidth: 32, frameHeight: 32 });
    this.load.spritesheet('enemy_boss', 'sprites/enemy_boss.png', { frameWidth: 64, frameHeight: 64 });

    // Load projectile sprite
    this.load.image('projectile', 'sprites/projectile.png');

    console.log('Loading sprites...');

    // Add error handling for missing sprites
    this.load.on('loaderror', function(file) {
        console.warn('Failed to load:', file.key, '- Will use fallback graphics');
    });
}

function create() {
    // Get difficulty from menu
    gameState.difficulty = selectedDifficulty;
    console.log('Game started with difficulty:', gameState.difficulty);

    // Create enemy animations
    createEnemyAnimations(this);

    // Create tower animations
    createTowerAnimations(this);

    // Create path
    gameState.path = [
        { x: -20, y: 300 },
        { x: 150, y: 300 },
        { x: 150, y: 150 },
        { x: 350, y: 150 },
        { x: 350, y: 400 },
        { x: 550, y: 400 },
        { x: 550, y: 250 },
        { x: 750, y: 250 },
        { x: 820, y: 250 }
    ];
    
    // Draw background
    drawBackground(this);
    
    // Draw path
    drawPath(this);
    
    // Draw spawn and base
    drawSpawnAndBase(this);
    
    // Create UI
    createUI(this);
    
    // Setup input
    setupInput(this);
    
    // Initialize HUD
    updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
}

function drawBackground(scene) {
    const bg = scene.add.graphics();
    bg.fillStyle(0x4a7c59, 1);
    bg.fillRect(0, 0, 800, 600);
    
    // Grass patches
    for (let i = 0; i < 20; i++) {
        const x = Math.random() * 800;
        const y = Math.random() * 600;
        const size = 20 + Math.random() * 30;
        bg.fillStyle(0x3d6b4a, 0.3);
        bg.fillCircle(x, y, size);
    }
}

function drawPath(scene) {
    const graphics = scene.add.graphics();
    
    // Path shadow
    graphics.lineStyle(44, 0x000000, 0.2);
    graphics.beginPath();
    for (let i = 0; i < gameState.path.length; i++) {
        const point = gameState.path[i];
        if (i === 0) {
            graphics.moveTo(point.x + 2, point.y + 2);
        } else {
            graphics.lineTo(point.x + 2, point.y + 2);
        }
    }
    graphics.strokePath();
    
    // Main path
    graphics.lineStyle(40, 0x8b7355, 1);
    graphics.beginPath();
    for (let i = 0; i < gameState.path.length; i++) {
        const point = gameState.path[i];
        if (i === 0) {
            graphics.moveTo(point.x, point.y);
        } else {
            graphics.lineTo(point.x, point.y);
        }
    }
    graphics.strokePath();
}

function drawSpawnAndBase(scene) {
    const spawnPoint = gameState.path[0];
    const basePoint = gameState.path[gameState.path.length - 1];
    
    // Spawn portal
    const spawnGraphics = scene.add.graphics();
    spawnGraphics.fillStyle(0xff0000, 0.5);
    spawnGraphics.fillCircle(spawnPoint.x, spawnPoint.y, 35);
    spawnGraphics.lineStyle(3, 0xff0000, 1);
    spawnGraphics.strokeCircle(spawnPoint.x, spawnPoint.y, 35);
    
    scene.add.text(spawnPoint.x, spawnPoint.y - 50, 'SPAWN', {
        fontSize: '14px',
        color: '#ff0000',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 3
    }).setOrigin(0.5);
    
    // Base
    const baseGraphics = scene.add.graphics();
    baseGraphics.fillStyle(0x8b8b8b, 1);
    baseGraphics.fillRect(basePoint.x - 30, basePoint.y - 40, 60, 80);
    baseGraphics.lineStyle(3, 0x00ff00, 1);
    baseGraphics.strokeRect(basePoint.x - 32, basePoint.y - 42, 64, 84);
    
    scene.add.text(basePoint.x, basePoint.y - 85, 'BASE', {
        fontSize: '16px',
        color: '#00ff00',
        fontStyle: 'bold',
        stroke: '#000000',
        strokeThickness: 3
    }).setOrigin(0.5);
    
    // Base health bar
    gameState.base = {
        x: basePoint.x,
        y: basePoint.y,
        healthBarBg: scene.add.rectangle(basePoint.x, basePoint.y + 55, 60, 8, 0x000000),
        healthBar: scene.add.rectangle(basePoint.x, basePoint.y + 55, 60, 8, 0x00ff00)
    };
}

function checkTowerUnlocks(scene) {
    // Check if Support Aura should be unlocked
    if (!gameState.unlockedTowers.includes('math-cannon')) {
        const requirement = TOWER_TYPES['math-cannon'].unlockRequirement;
        
        if (gameState.difficulty === requirement.difficulty && 
            gameState.totalProblemsCompleted >= requirement.problems) {
            console.log('√∞≈∏≈Ω‚Ä∞ UNLOCKED: Support Aura tower!');
            gameState.unlockedTowers.push('math-cannon');
            
            // Update the UI to show it's unlocked
            if (scene && scene.towerButtons) {
                updateTowerButtonUI(scene);
            }
        }
    }
}

function updateTowerButtonUI(scene) {
    // Update tower buttons to reflect unlocked state
    for (const buttonData of scene.towerButtons) {
        const key = buttonData.key;
        const isUnlocked = gameState.unlockedTowers.includes(key);
        
        if (isUnlocked) {
            buttonData.button.setFillStyle(0x4a4a4a);
            buttonData.button.setStrokeStyle(2, 0xffffff);
            buttonData.button.setInteractive({ useHandCursor: true });
            buttonData.text.setText(TOWER_TYPES[key].name + '\n' + TOWER_TYPES[key].cost + 'g');
            buttonData.text.setColor('#ffffff');
            
            // Add click handler if not already added
            buttonData.button.removeAllListeners('pointerdown');
            buttonData.button.on('pointerdown', () => {
                console.log('Button clicked:', key);
                selectTowerType(scene, key);
            });
        }
    }
}

function createUI(scene) {
    const towerButtons = [];
    let yPos = 20;
    
    for (const [key, tower] of Object.entries(TOWER_TYPES)) {
        const isUnlocked = gameState.unlockedTowers.includes(key);
        
        const button = scene.add.rectangle(720, yPos, 140, 50, isUnlocked ? 0x4a4a4a : 0x2a2a2a);
        button.setStrokeStyle(2, isUnlocked ? 0xffffff : 0x666666);
        
        if (isUnlocked) {
            button.setInteractive({ useHandCursor: true });
        }
        
        const text = scene.add.text(720, yPos, 
            isUnlocked ? `${tower.name}\n${tower.cost}g` : 'LOCKED', 
            {
                fontSize: '11px',
                color: isUnlocked ? '#ffffff' : '#666666',
                align: 'center'
            }
        ).setOrigin(0.5);
        
        if (isUnlocked) {
            button.on('pointerdown', () => {
                console.log('Button clicked:', key);
                selectTowerType(scene, key);
            });
        }
        
        towerButtons.push({ button, text, key });
        yPos += 70;
    }
    
    // Wave button
    const waveButton = scene.add.rectangle(720, 450, 140, 50, 0x00aa00);
    waveButton.setStrokeStyle(2, 0xffffff);
    waveButton.setInteractive({ useHandCursor: true });
    const waveText = scene.add.text(720, 450, 'Start Wave 1', {
        fontSize: '16px',
        color: '#ffffff'
    }).setOrigin(0.5);
    
    waveButton.on('pointerdown', () => {
        console.log('Wave button clicked!');
        console.log('waveInProgress:', gameState.waveInProgress);
        console.log('gameOver:', gameState.gameOver);
        
        if (!gameState.waveInProgress && !gameState.gameOver) {
            // IMMEDIATELY disable the button and update state to prevent multiple clicks
            gameState.waveInProgress = true;
            waveButton.disableInteractive();
            waveButton.setFillStyle(0x666666);
            waveText.setText('Wave in Progress...');
            waveText.setColor('#aaaaaa');
            console.log('Button disabled immediately');
            
            // Now start the wave
            startWave(scene);
        } else {
            console.log('Wave button click ignored - wave in progress or game over');
        }
    });
    
    scene.towerButtons = towerButtons;
    scene.waveButton = waveButton;
    scene.waveText = waveText;
    console.log('UI created - waveButton and waveText stored on scene');
}

function selectTowerType(scene, towerType) {
    console.log('selectTowerType called with:', towerType);
    
    // Prevent tower selection if game is over
    if (gameState.gameOver) {
        return;
    }
    
    // IMPORTANT: Clean up any existing preview first (fixes ghost towers)
    if (gameState.isPlacingTower) {
        if (gameState.preview.tower) gameState.preview.tower.destroy();
        if (gameState.preview.range) gameState.preview.range.destroy();
        if (gameState.preview.cost) gameState.preview.cost.destroy();
        gameState.preview = { tower: null, range: null, cost: null };
    }
    
    gameState.selectedTowerType = towerType;
    gameState.isPlacingTower = true;
    gameState.pendingPlacement = null; // Clear any pending placement
    
    const towerDef = TOWER_TYPES[towerType];
    
    // Create NEW preview elements
    gameState.preview.tower = scene.add.circle(0, 0, 15, towerDef.color, 0.5);
    gameState.preview.range = scene.add.circle(0, 0, towerDef.range, 0xffffff, 0);
    gameState.preview.range.setStrokeStyle(2, 0xffffff, 0.5);
    gameState.preview.cost = scene.add.text(0, 0, `Cost: ${towerDef.cost}g`, {
        fontSize: '14px',
        color: '#ffff00',
        stroke: '#000000',
        strokeThickness: 3
    }).setOrigin(0.5);
    
    // Show placement controls for mobile
    document.getElementById('placementControls').classList.add('active');
    
    console.log('Preview created - tap game area to position, then tap Confirm');
}

function setupInput(scene) {
    // Mouse move to show preview
    scene.input.on('pointermove', (pointer) => {
        if (gameState.isPlacingTower) {
            gameState.preview.tower.setPosition(pointer.x, pointer.y);
            gameState.preview.range.setPosition(pointer.x, pointer.y);
            gameState.preview.cost.setPosition(pointer.x, pointer.y - 25);
            
            // Check if placement is valid AND player can afford it
            const towerDef = TOWER_TYPES[gameState.selectedTowerType];
            const canPlace = pointer.x < 650 && !isOnPath(pointer.x, pointer.y);
            const canAfford = gameState.gold >= towerDef.cost;
            
            if (canPlace && canAfford) {
                gameState.preview.tower.setAlpha(0.7);
                gameState.preview.cost.setColor('#00ff00');
            } else {
                gameState.preview.tower.setAlpha(0.3);
                gameState.preview.cost.setColor('#ff0000');
                if (!canAfford) {
                    gameState.preview.cost.setText(`Need ${towerDef.cost}g`);
                } else {
                    gameState.preview.cost.setText(`Cost: ${towerDef.cost}g`);
                }
            }
        }
    });
    
    // Click/Tap to position preview (not place yet)
    scene.input.on('pointerdown', (pointer) => {
        // Ignore if game is over
        if (gameState.gameOver) {
            return;
        }
        
        // Ignore clicks in UI area (right side)
        if (pointer.x >= 650) {
            return;
        }
        
        if (gameState.isPlacingTower) {
            const towerDef = TOWER_TYPES[gameState.selectedTowerType];
            
            if (pointer.x < 650 && !isOnPath(pointer.x, pointer.y)) {
                // Just store the position - don't place yet
                // User needs to tap "Confirm" button to actually place
                gameState.pendingPlacement = {
                    x: pointer.x,
                    y: pointer.y,
                    type: gameState.selectedTowerType,
                    scene: scene
                };
                
                console.log('Position selected at', pointer.x, pointer.y, '- tap Confirm to place');
            }
        }
    });
    
    // Keyboard controls - Cancel placement with C or ESC
    scene.input.keyboard.on('keydown-C', () => {
        cancelTowerPlacement();
    });
    
    scene.input.keyboard.on('keydown-ESC', () => {
        cancelTowerPlacement();
    });
    
    // Keyboard controls - Confirm placement with Enter
    scene.input.keyboard.on('keydown-ENTER', () => {
        if (gameState.isPlacingTower && gameState.pendingPlacement) {
            console.log('Enter pressed - confirming placement');
            confirmTowerPlacement();
        }
    });
}

function cancelTowerPlacement() {
    console.log('Cancelling tower placement');
    if (gameState.isPlacingTower) {
        cleanupPlacement();
    }
}

function confirmTowerPlacement() {
    console.log('confirmTowerPlacement called');
    console.log('isPlacingTower:', gameState.isPlacingTower);
    console.log('pendingPlacement:', gameState.pendingPlacement);
    
    if (!gameState.isPlacingTower) {
        console.log('Not in placement mode');
        return;
    }
    
    if (!gameState.pendingPlacement) {
        console.log('No placement position selected yet - tap the game area first');
        return;
    }
    
    const towerDef = TOWER_TYPES[gameState.selectedTowerType];
    const scene = gameState.pendingPlacement.scene;
    
    if (!scene) {
        console.error('Scene reference lost! This should not happen.');
        cancelTowerPlacement();
        return;
    }
    
    // Check if player can afford the tower
    if (gameState.gold < towerDef.cost) {
        console.log('Cannot afford tower! Need', towerDef.cost, 'but only have', gameState.gold);
        alert(`Not enough gold! Need ${towerDef.cost}g but only have ${gameState.gold}g`);
        return;
    }
    
    // Check if placement is valid
    const x = gameState.pendingPlacement.x;
    const y = gameState.pendingPlacement.y;
    
    if (x >= 650 || isOnPath(x, y)) {
        console.log('Invalid placement location');
        alert('Invalid placement! Cannot place on path or UI area.');
        return;
    }
    
    // Determine time limit based on difficulty
    let timeLimit;
    if (gameState.difficulty === 'easy') {
        timeLimit = 60;
    } else if (gameState.difficulty === 'normal') {
        timeLimit = 30;
    } else {
        timeLimit = 20;
    }
    
    // Show math problem to buy tower
    const problem = generateMathProblem(gameState.difficulty, towerDef.cost);
    console.log('Confirming placement - showing math problem');
    
    showMathProblem(problem.question, timeLimit, (answered, answer) => {
        if (answered && answer === problem.answer) {
            // Correct! Award gold based on difficulty
            let goldReward = 0;
            if (gameState.difficulty === 'easy') {
                goldReward = 50;
            } else if (gameState.difficulty === 'normal') {
                goldReward = 75;
            } else {
                goldReward = 100;
            }
            
            gameState.gold += goldReward;
            console.log('Problem solved! Earned', goldReward, 'gold. Total gold:', gameState.gold);
            
            // Track the completion
            gameState.totalProblemsCompleted++;
            
            // Deduct tower cost
            gameState.gold -= towerDef.cost;
            console.log('Tower placed for', towerDef.cost, 'gold. Remaining:', gameState.gold);
            
            // Check if we should unlock new towers
            checkTowerUnlocks(scene);
            
            // Place the tower
            placeTower(scene, gameState.pendingPlacement.x, gameState.pendingPlacement.y, gameState.pendingPlacement.type);
            updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
        }
        
        // Clean up either way (success or failure)
        cleanupPlacement();
    });
}

// Helper function to clean up placement state
function cleanupPlacement() {
    console.log('Cleaning up placement state');
    
    gameState.pendingPlacement = null;
    
    // Clean up preview
    if (gameState.preview.tower) {
        gameState.preview.tower.destroy();
        gameState.preview.tower = null;
    }
    if (gameState.preview.range) {
        gameState.preview.range.destroy();
        gameState.preview.range = null;
    }
    if (gameState.preview.cost) {
        gameState.preview.cost.destroy();
        gameState.preview.cost = null;
    }
    
    gameState.isPlacingTower = false;
    gameState.selectedTowerType = null;
    
    // Hide placement controls
    document.getElementById('placementControls').classList.remove('active');
}

function showSellTowerModal(tower) {
    console.log('Showing sell modal for tower:', tower.type);
    
    gameState.selectedTowerToSell = tower;
    
    // Calculate sell price (50% of original cost)
    const sellPrice = Math.floor(tower.cost * 0.5);
    
    // Update modal text
    document.getElementById('sellTowerInfo').textContent = 
        `Sell ${tower.name} for ${sellPrice} gold? (50% refund)`;
    
    // Show modal and overlay
    document.getElementById('overlay').classList.add('active');
    document.getElementById('sellTowerModal').classList.add('active');
}

function confirmSellTower() {
    if (!gameState.selectedTowerToSell) {
        console.error('No tower selected to sell');
        return;
    }
    
    const tower = gameState.selectedTowerToSell;
    const sellPrice = Math.floor(tower.cost * 0.5);
    
    console.log('Selling tower for', sellPrice, 'gold');
    
    // Add gold
    gameState.gold += sellPrice;
    
    // Destroy tower graphics
    if (tower.graphic) tower.graphic.destroy();
    if (tower.rangeCircle) tower.rangeCircle.destroy();
    if (tower.readyIndicator) tower.readyIndicator.destroy();
    if (tower.auraGraphic) tower.auraGraphic.destroy();
    
    // Remove from towers array
    const index = gameState.towers.indexOf(tower);
    if (index > -1) {
        gameState.towers.splice(index, 1);
    }
    
    // Recalculate noise
    calculateNoise();
    
    // Update HUD
    updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
    
    // Close modal
    cancelSellTower();
    
    console.log('Tower sold successfully');
}

function cancelSellTower() {
    gameState.selectedTowerToSell = null;
    
    // Hide modal and overlay
    document.getElementById('overlay').classList.remove('active');
    document.getElementById('sellTowerModal').classList.remove('active');
}

function generateMathProblem(difficulty, towerCost) {
    console.log('generateMathProblem called with difficulty:', difficulty, 'towerCost:', towerCost);
    let num1, num2, operation, answer, question;
    
    // Scale difficulty based on tower cost
    const scale = Math.floor(towerCost / 50); // 100 cost = 2, 150 cost = 3, 200 cost = 4
    
    if (difficulty === 'easy') {
        // ONLY addition and subtraction with single digits and simple tens
        console.log('Easy difficulty detected - using only addition/subtraction');
        if (Math.random() < 0.5) {
            // Addition: either digit + digit or digit + tens
            if (Math.random() < 0.5) {
                // Single digit + single digit (1-9)
                num1 = Math.floor(Math.random() * 9) + 1;
                num2 = Math.floor(Math.random() * 9) + 1;
            } else {
                // Single digit + tens (10, 20, 30)
                num1 = Math.floor(Math.random() * 9) + 1;
                num2 = (Math.floor(Math.random() * 3) + 1) * 10; // 10, 20, or 30
            }
            answer = num1 + num2;
            question = `${num1} + ${num2} = ?`;
            console.log('Generated addition problem');
        } else {
            // Subtraction: either tens - digit or digit - digit
            if (Math.random() < 0.5) {
                // Tens - single digit (like 20 - 5)
                num1 = (Math.floor(Math.random() * 3) + 1) * 10; // 10, 20, or 30
                num2 = Math.floor(Math.random() * 9) + 1;
            } else {
                // Single digit - single digit (making sure num1 > num2)
                num2 = Math.floor(Math.random() * 9) + 1;
                num1 = num2 + Math.floor(Math.random() * (9 - num2)) + 1;
            }
            answer = num1 - num2;
            question = `${num1} - ${num2} = ?`;
            console.log('Generated subtraction problem');
        }
    } else if (difficulty === 'normal') {
        // Addition, subtraction, and multiplication
        const rand = Math.random();
        if (rand < 0.33) {
            num1 = Math.floor(Math.random() * (15 * scale)) + scale;
            num2 = Math.floor(Math.random() * (15 * scale)) + scale;
            answer = num1 + num2;
            question = `${num1} + ${num2} = ?`;
        } else if (rand < 0.66) {
            num1 = Math.floor(Math.random() * (15 * scale)) + (15 * scale);
            num2 = Math.floor(Math.random() * (10 * scale)) + scale;
            answer = num1 - num2;
            question = `${num1} - ${num2} = ?`;
        } else {
            num1 = Math.floor(Math.random() * (5 * scale)) + scale;
            num2 = Math.floor(Math.random() * (5 * scale)) + scale;
            answer = num1 * num2;
            question = `${num1} √É‚Äî ${num2} = ?`;
        }
    } else { // hard
        // Multiplication, division, and harder subtraction
        const rand = Math.random();
        if (rand < 0.4) {
            num1 = Math.floor(Math.random() * (8 * scale)) + scale;
            num2 = Math.floor(Math.random() * (8 * scale)) + scale;
            answer = num1 * num2;
            question = `${num1} √É‚Äî ${num2} = ?`;
        } else if (rand < 0.7) {
            num2 = Math.floor(Math.random() * (8 * scale)) + scale;
            answer = Math.floor(Math.random() * (10 * scale)) + scale;
            num1 = answer * num2;
            question = `${num1} √É¬∑ ${num2} = ?`;
        } else {
            num1 = Math.floor(Math.random() * (30 * scale)) + (20 * scale);
            num2 = Math.floor(Math.random() * (20 * scale)) + scale;
            answer = num1 - num2;
            question = `${num1} - ${num2} = ?`;
        }
    }
    
    return { question, answer };
}

function isOnPath(x, y) {
    for (let i = 0; i < gameState.path.length - 1; i++) {
        const p1 = gameState.path[i];
        const p2 = gameState.path[i + 1];
        const dist = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
        if (dist < 40) return true;
    }
    return false;
}

function distanceToLineSegment(x, y, x1, y1, x2, y2) {
    const A = x - x1;
    const B = y - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = lenSq !== 0 ? dot / lenSq : -1;
    
    let xx, yy;
    if (param < 0) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }
    
    const dx = x - xx;
    const dy = y - yy;
    return Math.sqrt(dx * dx + dy * dy);
}

function calculateNoise() {
    // Count auto-fire towers (towers that don't require math and aren't support)
    let autoFireCount = 0;
    for (const tower of gameState.towers) {
        if (!tower.requiresMath && !tower.isSupportTower) {
            autoFireCount++;
        }
    }
    
    // Noise per tower scales with difficulty
    let noisePerTower;
    if (gameState.difficulty === 'easy') {
        noisePerTower = 3;  // 17 towers to reach 50% threshold (more forgiving)
    } else if (gameState.difficulty === 'normal') {
        noisePerTower = 5;  // 10 towers to reach 50% threshold
    } else { // hard
        noisePerTower = 8;  // 7 towers to reach 50% threshold (encourages math towers)
    }
    
    gameState.noise = autoFireCount * noisePerTower;
    
    console.log('Noise calculated:', gameState.noise + '% (Auto-fire towers:', autoFireCount, '| Difficulty:', gameState.difficulty, '| Noise per tower:', noisePerTower + '%)');
    
    return gameState.noise;
}

function placeTower(scene, x, y, towerType) {
    const towerDef = TOWER_TYPES[towerType];

    const tower = {
        x, y,
        type: towerType,
        ...towerDef,
        lastFired: 0,
        level: 1,
        readyToFire: false,
        currentTarget: null,
        readyIndicator: null,
        scene: scene
    };

    // Special handling for basic tower with animations
    if (towerType === 'basic' && scene.textures.exists('tower_basic_idle')) {
        console.log('Using animated sprite for basic tower');
        tower.graphic = scene.add.sprite(x, y, 'tower_basic_idle');
        tower.graphic.setScale(1.5); // Scale up for better visibility

        // Play idle animation
        if (scene.anims.exists('tower_basic_idle')) {
            tower.graphic.play('tower_basic_idle');
        }
    } else {
        // Use sprite if available, otherwise fallback to circle
        const spriteKey = 'tower_' + towerType.replace('-', '_');
        if (scene.textures.exists(spriteKey)) {
            console.log('Using sprite:', spriteKey);
            tower.graphic = scene.add.sprite(x, y, spriteKey);
            tower.graphic.setScale(1.0); // Adjust scale as needed
        } else {
            // Fallback to colored circle
            console.log('No sprite found for', towerType, '- using circle fallback');
            tower.graphic = scene.add.circle(x, y, 15, towerDef.color);
            tower.graphic.setStrokeStyle(2, 0x000000);
        }
    }
    
    // Support towers get a special pulsing aura visual
    if (towerDef.isSupportTower) {
        tower.auraGraphic = scene.add.circle(x, y, towerDef.auraRange, 0xff6600, 0);
        tower.auraGraphic.setStrokeStyle(3, 0xff6600, 0.3);
        
        // Pulse animation for the aura
        scene.tweens.add({
            targets: tower.auraGraphic,
            alpha: { from: 0.1, to: 0.3 },
            scale: { from: 0.95, to: 1.05 },
            duration: 2000,
            yoyo: true,
            repeat: -1
        });
    }
    
    tower.rangeCircle = scene.add.circle(x, y, towerDef.range, 0x000000, 0);
    tower.rangeCircle.setStrokeStyle(2, 0xffffff, 0);
    
    tower.graphic.setInteractive({ useHandCursor: true });
    tower.graphic.on('pointerover', () => tower.rangeCircle.setAlpha(0.2));
    tower.graphic.on('pointerout', () => tower.rangeCircle.setAlpha(0));
    
    // Click handler for math towers
    tower.graphic.on('pointerdown', (pointer, localX, localY, event) => {
        console.log('Tower clicked! Type:', tower.type, 'RequiresMath:', tower.requiresMath, 'ReadyToFire:', tower.readyToFire, 'HasTarget:', !!tower.currentTarget);
        
        // Stop event propagation so it doesn't trigger placement handler
        event.stopPropagation();
        
        // Priority 1: If in sell mode, show sell modal
        if (gameState.sellMode) {
            console.log('Sell mode active - showing sell modal');
            showSellTowerModal(tower);
            return;
        }
        
        // Priority 2: If it's a math tower ready to fire, show math problem
        if (tower.requiresMath && tower.readyToFire && tower.currentTarget) {
            console.log('Math tower clicked, showing problem');
            
            // Determine time limit based on difficulty
            let timeLimit;
            if (gameState.difficulty === 'easy') {
                timeLimit = 30; // 30 seconds for tower firing in easy
            } else if (gameState.difficulty === 'normal') {
                timeLimit = 20;
            } else {
                timeLimit = 15;
            }
            
            const problem = generateMathProblem(gameState.difficulty, tower.cost);
            const savedTarget = tower.currentTarget;
            
            showMathProblem(problem.question, timeLimit, (answered, answer) => {
                if (answered && answer === problem.answer) {
                    // Correct! Award gold based on difficulty
                    let goldReward = 0;
                    if (gameState.difficulty === 'easy') {
                        goldReward = 50;
                    } else if (gameState.difficulty === 'normal') {
                        goldReward = 75;
                    } else { // hard
                        goldReward = 100;
                    }
                    
                    gameState.gold += goldReward;
                    console.log('Problem solved! Earned', goldReward, 'gold. Total gold:', gameState.gold);
                    
                    // Track the completion
                    gameState.totalProblemsCompleted++;
                    
                    // Check if we should unlock new towers
                    checkTowerUnlocks(tower.scene);
                    
                    // Fire the tower
                    if (savedTarget && savedTarget.graphic && savedTarget.graphic.active) {
                        fireTower(tower.scene, tower, savedTarget);
                        console.log('Math tower fired at target!');
                        
                        // Set cooldown after firing - use Phaser's time system
                        if (tower.scene && tower.scene.time) {
                            tower.lastFired = tower.scene.time.now;
                            console.log('Tower cooldown started. LastFired set to:', tower.lastFired);
                        } else {
                            // Fallback: set to 0 so it can fire again after cooldown
                            console.warn('Could not access scene.time, tower will be ready immediately');
                            tower.lastFired = 0;
                        }
                    } else {
                        console.log('Target no longer valid - cannot fire');
                    }
                    
                    // Update HUD to show new gold amount
                    updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
                } else {
                    // Wrong answer or timeout - no gold, no shot, but no cooldown penalty
                    console.log('Math problem failed - tower will be ready again immediately');
                    tower.lastFired = 0; // No cooldown penalty for wrong answer
                }
                
                // ALWAYS reset these states
                tower.readyToFire = false;
                tower.currentTarget = null;
                
                // Remove ready indicator
                if (tower.readyIndicator) {
                    tower.readyIndicator.destroy();
                    tower.readyIndicator = null;
                }
            });
        }
        // Priority 3: Otherwise, just show info (or show sell modal)
        else {
            console.log('Tower clicked but not ready to fire - showing sell modal');
            showSellTowerModal(tower);
        }
    });
    
    gameState.towers.push(tower);
    
    // Recalculate noise level
    calculateNoise();
}

function startWave(scene) {
    console.log('Starting wave - waveInProgress already set to:', gameState.waveInProgress);
    
    // Increment wave counter
    gameState.wave++;
    updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
    
    // Set up spawn tracking - enemies increase more dramatically each wave
    const baseEnemyCount = 5 + gameState.wave * 3; // Increased from *2 to *3 for faster scaling
    const isBossWave = gameState.wave % 5 === 0;
    const enemyCount = isBossWave ? baseEnemyCount + 1 : baseEnemyCount; // Add 1 boss
    
    gameState.totalEnemiesToSpawn = enemyCount;
    gameState.enemiesSpawnedThisWave = 0;
    console.log('Wave', gameState.wave, '- Will spawn', enemyCount, 'enemies', isBossWave ? '(BOSS WAVE!)' : '');
    
    // Double-check button is disabled (it should already be from the click handler)
    if (scene.waveButton && scene.waveText) {
        console.log('Confirming wave button is disabled');
        scene.waveButton.disableInteractive();
        scene.waveButton.setFillStyle(0x666666);
        scene.waveText.setText(isBossWave ? 'BOSS WAVE!' : 'Wave in Progress...');
        scene.waveText.setColor(isBossWave ? '#ff00ff' : '#aaaaaa');
    } else {
        console.error('Wave button or text not found!');
    }
    
    // Spawn regular enemies (mix of basic and fast)
    scene.time.addEvent({
        delay: 1000,
        repeat: baseEnemyCount - 1,
        callback: () => {
            // 30% chance to spawn fast enemy, 70% chance for basic
            const enemyType = Math.random() < 0.3 ? 'fast' : 'basic';
            spawnEnemy(scene, enemyType);
        }
    });
    
    // Spawn boss at the end if it's a boss wave
    if (isBossWave) {
        scene.time.addEvent({
            delay: 1000 * (baseEnemyCount + 2), // Boss spawns 2 seconds after last regular enemy
            callback: () => {
                spawnEnemy(scene, 'boss');
            }
        });
    }
}

function showGameOver(scene) {
    gameState.gameOver = true;
    
    // Update final stats
    document.getElementById('finalScore').textContent = gameState.score;
    document.getElementById('finalWave').textContent = gameState.wave;
    document.getElementById('finalEnemies').textContent = gameState.enemiesDefeated;
    
    // Show game over modal
    document.getElementById('overlay').classList.add('active');
    document.getElementById('gameOverModal').classList.add('active');
    
    // Disable wave button
    if (scene.waveButton && scene.waveText) {
        scene.waveButton.setFillStyle(0x666666);
        scene.waveButton.disableInteractive();
        scene.waveText.setText('Game Over');
        scene.waveText.setColor('#ff6b6b'); // Red text for game over
    }
}

function spawnEnemy(scene, type = 'basic') {
    const enemyDef = ENEMY_TYPES[type];

    const enemy = {
        type,
        health: enemyDef.health,
        maxHealth: enemyDef.health,
        speed: enemyDef.speed,
        gold: enemyDef.gold,
        isBoss: enemyDef.isBoss || false,
        pathIndex: 0,
        x: gameState.path[0].x,
        y: gameState.path[0].y,
        slowEffect: 1
    };

    // Use sprite if available, otherwise fallback to circle
    const spriteKey = 'enemy_' + type;
    if (scene.textures.exists(spriteKey)) {
        enemy.graphic = scene.add.sprite(enemy.x, enemy.y, spriteKey);

        // Play walking animation
        const animKey = spriteKey + '_walk';
        if (scene.anims.exists(animKey)) {
            enemy.graphic.play(animKey);
        }

        // Set scale based on type
        if (enemy.isBoss) {
            enemy.graphic.setScale(1.2);
        } else {
            enemy.graphic.setScale(1.0);
        }
    } else {
        // Fallback to colored circle
        const size = enemy.isBoss ? 15 : 8;
        enemy.graphic = scene.add.circle(enemy.x, enemy.y, size, enemyDef.color);
        enemy.graphic.setStrokeStyle(enemy.isBoss ? 4 : 2, 0x000000);
    }
    
    // Boss crown indicator
    if (enemy.isBoss) {
        enemy.crownText = scene.add.text(enemy.x, enemy.y - 25, 'üëë', {
            fontSize: '20px'
        }).setOrigin(0.5);
    }
    
    const healthBarWidth = enemy.isBoss ? 40 : 20;
    enemy.healthBarBg = scene.add.rectangle(enemy.x, enemy.y - 15, healthBarWidth, 3, 0x000000);
    enemy.healthBar = scene.add.rectangle(enemy.x, enemy.y - 15, healthBarWidth, 3, 0x00ff00);
    
    gameState.enemies.push(enemy);
    gameState.enemiesSpawnedThisWave++;
    console.log('Enemy spawned (' + type + '):', gameState.enemiesSpawnedThisWave, '/', gameState.totalEnemiesToSpawn);
}

function update(time, delta) {
    // Don't update if game is over
    if (gameState.gameOver) {
        return;
    }
    
    // Check for game over
    if (gameState.health <= 0) {
        showGameOver(this);
        return;
    }
    
    // Update enemies
    for (let i = gameState.enemies.length - 1; i >= 0; i--) {
        const enemy = gameState.enemies[i];
        
        if (enemy.pathIndex < gameState.path.length - 1) {
            const target = gameState.path[enemy.pathIndex + 1];
            const dx = target.x - enemy.x;
            const dy = target.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 5) {
                enemy.pathIndex++;
            } else {
                const speed = (enemy.speed * delta) / 1000;
                enemy.x += (dx / distance) * speed;
                enemy.y += (dy / distance) * speed;
                
                enemy.graphic.setPosition(enemy.x, enemy.y);
                enemy.healthBarBg.setPosition(enemy.x, enemy.y - 15);
                enemy.healthBar.setPosition(enemy.x, enemy.y - 15);
                
                // Update crown text for bosses
                if (enemy.crownText) {
                    enemy.crownText.setPosition(enemy.x, enemy.y - 25);
                }
            }
        } else {
            // Reached base
            gameState.health -= 10;
            updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
            
            if (gameState.base && gameState.base.healthBar) {
                const healthPercent = gameState.health / 100;
                gameState.base.healthBar.setScale(healthPercent, 1);
                
                if (healthPercent < 0.3) {
                    gameState.base.healthBar.setFillStyle(0xff0000);
                } else if (healthPercent < 0.6) {
                    gameState.base.healthBar.setFillStyle(0xffff00);
                }
            }
            
            enemy.graphic.destroy();
            enemy.healthBarBg.destroy();
            enemy.healthBar.destroy();
            if (enemy.crownText) enemy.crownText.destroy();
            gameState.enemies.splice(i, 1);
            
            // Check for game over after enemy reaches base
            if (gameState.health <= 0) {
                showGameOver(this);
                return;
            }
        }
    }
    
    // Update towers
    for (const tower of gameState.towers) {
        // Skip support towers - they don't fire
        if (tower.isSupportTower) {
            continue;
        }
        
        if (time - tower.lastFired > tower.fireRate) {
            const target = findEnemyInRange(tower);
            
            if (target) {
                if (tower.requiresMath) {
                    // Check if there's a support tower nearby providing auto-fire for bosses
                    const hasSupportAura = checkForSupportAura(tower);
                    const shouldAutoFire = hasSupportAura && target.isBoss;
                    
                    if (shouldAutoFire) {
                        // Auto-fire at boss thanks to support tower
                        console.log('Math tower auto-firing at boss due to support aura!');
                        fireTower(this, tower, target);
                        tower.lastFired = time;
                        
                        // Remove ready indicator if any
                        if (tower.readyIndicator) {
                            tower.readyIndicator.destroy();
                            tower.readyIndicator = null;
                        }
                        tower.readyToFire = false;
                        tower.currentTarget = null;
                    } else {
                        // Normal math tower behavior - show ready indicator
                        if (!tower.readyIndicator) {
                            // Create a pulsing indicator
                            tower.readyIndicator = this.add.circle(tower.x, tower.y, 20, 0xffff00, 0);
                            tower.readyIndicator.setStrokeStyle(3, 0xffff00, 0.8);
                            
                            // Pulse animation
                            this.tweens.add({
                                targets: tower.readyIndicator,
                                alpha: { from: 0.3, to: 0.8 },
                                scale: { from: 0.9, to: 1.1 },
                                duration: 500,
                                yoyo: true,
                                repeat: -1
                            });
                        }
                        tower.currentTarget = target;
                        tower.readyToFire = true;
                    }
                } else {
                    // Auto tower - fire automatically
                    fireTower(this, tower, target);
                    tower.lastFired = time;
                }
            } else {
                // No target - remove ready indicator
                if (tower.readyIndicator) {
                    tower.readyIndicator.destroy();
                    tower.readyIndicator = null;
                }
                tower.readyToFire = false;
                tower.currentTarget = null;
            }
        }
    }
    
    // Update projectiles
    for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
        const proj = gameState.projectiles[i];
        
        if (proj.target && proj.target.graphic && proj.target.graphic.active) {
            const dx = proj.target.x - proj.x;
            const dy = proj.target.y - proj.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 10) {
                // Check for miss chance if noise >= 50% and projectile is from auto-fire tower
                let missed = false;
                if (proj.isAutoFire && gameState.noise >= 50) {
                    // Miss chance increases with noise level
                    // At 50% noise = 20% miss chance, at 100% noise = 50% miss chance
                    const missChance = Math.min(0.5, (gameState.noise - 50) / 100 + 0.2);
                    missed = Math.random() < missChance;

                    if (missed) {
                        console.log('Shot missed due to high noise! (', Math.round(missChance * 100), '% miss chance)');
                    }
                }

                // Only damage if didn't miss
                if (!missed) {
                    damageEnemy(proj.target, proj.damage);
                }

                proj.graphic.destroy();
                gameState.projectiles.splice(i, 1);
            } else {
                const speed = (300 * delta) / 1000;
                proj.x += (dx / distance) * speed;
                proj.y += (dy / distance) * speed;
                proj.graphic.setPosition(proj.x, proj.y);

                // Update rotation if it's a sprite
                if (proj.graphic.type === 'Sprite') {
                    const angle = Phaser.Math.Angle.Between(proj.x, proj.y, proj.target.x, proj.target.y);
                    proj.graphic.setRotation(angle);
                }
            }
        } else {
            proj.graphic.destroy();
            gameState.projectiles.splice(i, 1);
        }
    }
    
    // Check wave complete - only when all enemies have spawned AND been defeated/reached base
    if (gameState.waveInProgress && 
        gameState.enemiesSpawnedThisWave >= gameState.totalEnemiesToSpawn && 
        gameState.enemies.length === 0) {
        console.log('Wave complete! All', gameState.totalEnemiesToSpawn, 'enemies spawned and cleared. Re-enabling button');
        gameState.waveInProgress = false;
        
        // Award 100 gold for completing the wave
        gameState.gold += 100;
        console.log('Wave completed! Earned 100 gold. Total:', gameState.gold);
        
        updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
        
        // Re-enable wave button with green color
        if (this.waveButton && this.waveText) {
            console.log('Updating button to green and next wave text');
            this.waveButton.setFillStyle(0x00aa00); // Green
            this.waveButton.setInteractive({ useHandCursor: true }); // Re-enable clicking
            this.waveText.setText('Start Wave ' + (gameState.wave + 1));
            this.waveText.setColor('#ffffff'); // White text
        } else {
            console.error('Wave button/text not found in update!');
        }
    }
}

function findEnemyInRange(tower) {
    for (const enemy of gameState.enemies) {
        const dx = enemy.x - tower.x;
        const dy = enemy.y - tower.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance <= tower.range) return enemy;
    }
    return null;
}

function checkForSupportAura(tower) {
    // Check if there's a support tower within range of this tower
    for (const supportTower of gameState.towers) {
        if (supportTower.isSupportTower) {
            const dx = tower.x - supportTower.x;
            const dy = tower.y - supportTower.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= supportTower.auraRange) {
                return true;
            }
        }
    }
    return false;
}

function fireTower(scene, tower, target) {
    console.log('fireTower called! Tower:', tower.type, 'Target:', target.type, 'Scene:', !!scene);

    // Play fire animation for basic tower
    if (tower.type === 'basic' && tower.graphic && tower.graphic.anims) {
        if (scene.anims.exists('tower_basic_fire')) {
            tower.graphic.play('tower_basic_fire');

            // Return to idle after fire animation completes
            tower.graphic.once('animationcomplete', () => {
                if (scene.anims.exists('tower_basic_idle')) {
                    tower.graphic.play('tower_basic_idle');
                }
            });
        }
    }

    const projectile = {
        x: tower.x,
        y: tower.y,
        target: target,
        damage: tower.damage,
        isAutoFire: !tower.requiresMath && !tower.isSupportTower  // Track if from auto-fire tower
    };

    console.log('Creating projectile graphic at', tower.x, tower.y);

    // Use sprite if available, otherwise fallback to circle
    if (scene.textures.exists('projectile')) {
        projectile.graphic = scene.add.sprite(tower.x, tower.y, 'projectile');
        projectile.graphic.setScale(0.5);

        // Add rotation to face the target
        const angle = Phaser.Math.Angle.Between(tower.x, tower.y, target.x, target.y);
        projectile.graphic.setRotation(angle);
    } else {
        // Fallback to colored circle
        projectile.graphic = scene.add.circle(tower.x, tower.y, 4, 0xffff00);
    }

    gameState.projectiles.push(projectile);
    console.log('Projectile added. Total projectiles:', gameState.projectiles.length);
}

function damageEnemy(enemy, damage) {
    enemy.health -= damage;
    const healthPercent = enemy.health / enemy.maxHealth;
    enemy.healthBar.setScale(healthPercent, 1);
    
    if (healthPercent < 0.3) {
        enemy.healthBar.setFillStyle(0xff0000);
    } else if (healthPercent < 0.6) {
        enemy.healthBar.setFillStyle(0xffff00);
    }
    
    if (enemy.health <= 0) {
        gameState.gold += enemy.gold;
        gameState.score += enemy.gold * 5;
        gameState.enemiesDefeated++; // Track defeated enemies
        console.log('Enemy defeated! Earned', enemy.gold, 'gold. Total:', gameState.gold);
        updateHUD(gameState.gold, gameState.health, gameState.wave, gameState.score, gameState.noise);
        
        enemy.graphic.destroy();
        enemy.healthBarBg.destroy();
        enemy.healthBar.destroy();
        if (enemy.crownText) enemy.crownText.destroy();
        
        const index = gameState.enemies.indexOf(enemy);
        if (index > -1) gameState.enemies.splice(index, 1);
    }
}
    </script>
</body>
</html>
